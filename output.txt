 IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>





s.html">publications</a>

html">WG21 papers</a>

tml">TC++PL</a>

.html">Tour++</a>

amming.html">Programming</a>

tml">D&amp;E</a>

tml">bio</a>

views.html">interviews</a>

"http://www.stroustrup.com/videos.html">videos</a>

"http://www.stroustrup.com/applications.html">applications</a>

"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

"http://www.stroustrup.com/compilers.html">compilers</a>

>



ref="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

>

="right">

 November 22, 2019

e questions about C++ Style and Technique that people ask me often.

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

q2.html#int-to-string">

</a>

</a>

www.stroustrup.com/bs_faq2.html#no-derivation">

e deriving from my class?</a>

on">

Fruit&gt;?</a>

om/bs_faq2.html#exceptions">

om/bs_faq2.html#resume">

g an exception?</a>

om/bs_faq2.html#finally">

ly" construct?</a>

q2.html#evaluation-order">

al-align: inherit;">

nt><font style="vertical-align: inherit;">//错误返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

/font><font></font>

;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

/a>.

erit;"><font style="vertical-align: inherit;"> “标准库游览”一章

 </font><font style="vertical-align: inherit;">

介绍准则项目的</font></font><a href="http://www.stroustrup.com/C++.html#videos"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p>

但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

hapes的实现者）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

类别：公共形状{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

t;">

者（例如Circle和Triangle）共享受保护成员表示的实现方面。

nherit;">



ertical-align: inherit;"><font style="vertical-align: inheri IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>





"http://www.stroustrup.com/videos.html">videos</a>

increasingly sporadic.

/a>

rogram">

tandard">

s</a>:

ustrup.com/bs_faq2.html#layout-obj">

uctors?</a>

om/bs_faq2.html#virtual-dtor">

q2.html#generics">

 been?</a>

l>

>

www.stroustrup.com/bs_faq2.html#resume">

me after catching an exception?</a>

>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

ements<font></font>

nt></font>

t>

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

herit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">只要该类具有至少一个虚函数。</font><font style="vertical-align: inherit;">具有虚函数表示类旨在充当派生类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

>

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型t;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

ty {};</font></font><font></font>

ign: inherit;">

;">

: inherit;">

	}	</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

有一条有趣的规则说空的基类不需要用单独的字节表示：

简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

style="vertical-align: inherit;">

必需的。

多类并未设计为用作基类。</font><font style="vertical-align: inherit;">例如，参见</font></font><a href="http://www.stroustrup.com/bs_faq2.html#data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

具有虚拟功能的类的对象需要虚拟功能调用机制所需的空间-通常每个对象一个字。</font><font style="vertical-align: inherit;">这种开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

而被破坏。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">//用于确保〜Derived被调用的虚拟析构函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

_a_B（）const = 0;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;">

的知识完全隔离。

0; </font><font style="vertical-align: inherit;">//纯虚拟</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	f（双精度）：3.3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	f（双精度）：3.6</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而不是

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	f（整数）：3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	f（双精度）：3.6</font></font><font></font>

tical-align: inherit;">

;">请参见

虑：

lign: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;"> D :: f。</font><font style="vertical-align: inherit;">考虑如果规则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运行构造函。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

t;">

herit;">实际上，仅具有纯虚函数的类通常称为接口。

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函 IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

信息，请参见

a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font>

位置删除”来匹配新的展示位置的原因是，没有确保其正确使用的通用方法。</font><font style="vertical-align: inherit;">C ++类型系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

ical-align: inherit;">

以使用一些笨拙的技术：

vertical-align: inherit;"><font style="vertical-align: inherit;">	类可用；</font></font><font></font>

style="vertical-align: inherit;">也就是说，它们拥有相同类型的元素。</font><font style="vertical-align: inherit;">如果希望容器包含几种不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

ical-align: inherit;"><font style="vertical-align: inherit;">	vector &lt;Shape *&gt; vi; </font><font style="vertical-align: inherit;">//形状的指针向量

l-align: inherit;"><font style="vertical-align: inherit;">

这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

译时错误消息，并且不会造成不必要的运行时开销。

个容器。</font><font style="vertical-align: inherit;">例如：

* ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

7）; </font><font style="vertical-align: inherit;">//将7的一个副本放入vi</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

＆im）; </font><font style="vertical-align: inherit;">//将＆im（的副本）放入vim</font></font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

>

ently occuring genuine performance problem is the use of a map&lt;string,X&gt; for

f (string,X) pairs.

ion,

合标准的程序中）不能在不修改类源的情况下授予自己访问类的权限。</font><font style="vertical-align: inherit;">例如：

 style="vertical-align: inherit;"><font style="ver数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

font></font>

/font>

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

</font></font><p>

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

>

l-align: inherit;">

font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

style="vertical-align: inherit;">这导致灾难：退出f（）时，将调用h1和h2的析构函数，并将h1.p和h2.p指向的对象删除两次。

erit;">

-align: inherit;"><font style="vertical-align: inherit;">

下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数 IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

increasingly sporadic.

/a>

rogram">

tandard">

s</a>:

ustrup.com/bs_faq2.html#layout-obj">

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

delete-zero">

-operator">

+ i++?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

ements<font></font>

nt></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

 not have to depend on. For example, many

be logically independent of the definition

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

gn: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-alitical-align: inherit;">	X类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

问X :: i * /}</font></font><font></font>

问X :: i * /}</font></font><font></font>

e="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

析构函数，并将h1.p和h2.p指向的对象删除两次。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们如何避免这种情况？</font><font style="vertical-align: inherit;">最简单的解决方案是通过将复制操作设为私有来防止复制：

it;">//防止复制</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">对于Point，默认的复制语义很好，问题出在构造函数上：

<font style="vertical-align: inherit;">

"vertical-align: inherit;">

,0）创建orig</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// 丑陋</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

herit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

 inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

＆）;

n: inherit;">// 增量</font></font><font></font>

t style="vertical-align: inherit;">

是应该使用引用？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

;">

it;">

"vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

id f（int a []，int b []，int size）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		a = b;	</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

it;">

al"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

有final关键字？</font></font></a></h2>

www.stroustrup.com/bs_faq2.html#no-derivation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它有，但是没有您想象的有用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

cal-align: inherit;">我更喜欢避免使用宏，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免 IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

"http://www.stroustrup.com/videos.html">videos</a>

"http://www.stroustrup.com/applications.html">applications</a>

delete-zero">

www.stroustrup.com/bs_faq2.html#resume">

+ i++?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

herit;">

素</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;"
>

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

ements<font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

 not have to depend on. For example, many

be logically independent of the definition

Color in the definition of Shape will probably

les defining the operating system's notion of

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

t;">

lign: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

;"><font style="vertical-align: inherit;">

herit;">

rit;">

herit;">

>

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

对象的地址不同。</font><font st显式的：

rit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为在某些情况下，这样可以更轻松地发现可能进行修改。 

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

">

cal-align: inherit;">

style="vertical-align: inherit;">

>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

realloc（）在免费存储区中分配</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

"vertical-align: inherit;">另一个示例是：

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

>

herit;">

lign: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

"http://www.stroustrup.com/videos.html">videos</a>

"http://www.stroustrup.com/applications.html">applications</a>

"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

increasingly sporadic.

q2.html#generics">

 been?</a>

l>

>

"memory">Memory</a>:

delete-zero">

-operator">

+ i++?</a>

ustrup.com/bs_faq2.html#undefined">

 undefined in C++?</a>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

ements<font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

rit;">

: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

align: inherit;">

t;">

lign: inherit;">

gn: inherit;">

lign: inherit;">

>

nherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

herit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="ver IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

uctors?</a>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

l>

>

delete-zero">

www.stroustrup.com/bs_faq2.html#resume">

-operator">

+ i++?</a>

;">

>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

s.html">my publications list</a>.

 format.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

e, the user need not be concerned with the allocation and

tion of memory for vector elements.

>

ing in strings, see

"http://www.stroustrup.com/bs_faq2.html#read-string">How do I read a string from input?</a>.

>

ements<font></font>

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

for C++) and don't use ten-year-old

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

rit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

>

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		B * q = fac.make_a_B（）; </font><font style="vertical-align: inherit;">//制作适当类型的B</font></font><fo IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

"http://www.stroustrup.com/videos.html">videos</a>

"http://www.stroustrup.com/applications.html">applications</a>

"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

/a>

q2.html#generics">

 been?</a>

delete-zero">

-operator">

;">

herit;">

素</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

e, the user need not be concerned with the allocation and

ements<font></font>

nt></font>

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

uidelines.md"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

cal-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

for C++) and don't use ten-year-old

andard C++.

rtical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

rit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a>gn: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		B * q = fac.make_a_B（）; </font><font style="vertical-align: inherit;">//制作适当类型的B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

体。</font><font style="vertical-align: inherit;">关键是user（）与AX和AY等类的知识完全隔离。

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D :: f。</font><font style="vertical-align: inherit;">考虑如果规则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运
行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

rtical-><font></font>

t style="vertical-align: inherit;">

mem_fun（＆Shape :: draw））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可能会写类似： 

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

it;">

然，除非这些是属性）正在受约束测试）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 b）{a == b; </font><font style="vertical-align: inherit;">a！= b; </font><font style="vertical-align: inherit;">a &lt;b; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

in（），vec.end（））;

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

>

即可使用它，并且他们不必为标准类型编写compare（）函数。

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

s.html">publications</a>

html">WG21 papers</a>

tml">TC++PL</a>

increasingly sporadic.

/a>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

-operator">

;">

>

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

for C++) and don't use ten-year-old

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

接口的类中。</font><font style="vertical-align: inherit;">而是将其放在派生类中。</font><font style="vertical-align: inherit;">看，</font></font><a href="http://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

t;">

herit;">实际上，仅具有纯虚函数的类通常称一</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

erit;">

事情。</font><font style="vertical-align: inherit;">不幸的是，我所知道的最好的解释是在一本书中，而这本书已经过时，并且没有描述任何当前的C ++实现：

考手册》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

 inherit;">另一个示例是：

t;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
lign: inherit;"><font style="vertical-align: inherit;">

;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">// j的值未指定</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

        无效draw_all（Container＆c）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

        {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

                for_each（c.begin（），c.end（），mem_fun（＆Shape :: draw））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

        }</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如果存在类型错误，它将解决相当复杂的for_each（）调用。</font><font style="vertical-align: inherit;">例如，如果容器的元素类型为int，则我们会得到与for_each（）调用相关的某种模糊错误（因为我们无法为int调用Shape :: draw（））。 

it;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

意，该定义具有以下理想属性：

约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

（elem），elem_compare）;

inherit;"><font style="vertical-align: inherit;">

 inherit;">



nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

<font style="vertical-align: inherit;">

内联调用。

>

e="vertical-align: inherit;">通过编写没有任何代码的代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

并出现泄漏，流浪指针等情况。这与您对分配的认真程度无关：代码的复杂性-align: inherit;">

ont style="vertical-align: inherit;">} //提取值</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

">

;">

检测器，或插入垃圾收集器。

="vertical-align: inherit;"><font style="vertical-align: inherit;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></p><p>

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个tical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

f（）函数的重载集怎么办？</font><font style="vertical-align: inherit;">使用using声明很容易做到：

rit;"><font style="vertical-align: inherit;">	D级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

（假设Java可能会重载+）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

</p><hr>

<h2><a name="placement-delete"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">

e="vertical-align: inherit;">        类竞技场{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: 象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是例外很昂贵！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： 并不是的。</font><font style="vertical-align: inherit;">现代C ++实现将使用异常的开销减少了百分之几（例如3％），这与没有错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

herit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

“ use f”部分抛出异常-或只是返回了-文件不会关闭。</font><font style="vertical-align: inherit;">在C程序中，longjmp（）是另外一个危险。

gn: inherit;">

ign: inherit;"><font style="vertical-aliyle="vertical-align: inherit;">由于相同的原因，“ new”总是返回指向不同对象的指针。</font><font style="vertical-align: inherit;">考虑：

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Empty {};</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

le="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

 inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

f（）函数的重载集怎么办？</font><font style="vertical-align: inherit;">使用using声明很容易做到：

rit;"><font style="vertical-align: inherit;">	D级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

rit;">//使B中的每个f都可用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

”; </font><font style="vertical-align: inherit;">返回d + 1.3; </fo="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#inalign: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

const Usable_lock＆）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

且有效的容器。</font><font style="vertical-align: inherit;">示例包括矢量，列表和地图：

"><font style="vertical-align: inherit;">	vector &lt;int&gt; vi（10）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-ali

gn: inherit;">

cal-align: inherit;">数组</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

gn: inherit;">

lign: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

且有效的容器。</font><font style="vertical-align: inherit;">示例包括矢量，列表和地图：

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，克服您可以负担的时间和精力。</font><font style="vertical-align: inherit;">随之而来的是，成功的技术依赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。
</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

迭代器那样的指针使用，但是对于这样一个很小的程序，这似乎有些过头了。

lt;内存&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

"vertical-align: inherit;">

it;">//明确转移删除此S的责任</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

存。

: inherit;"><font style="vertical-align: inherit;">

在哪里允许它都会导致严重的维护问题。

erit;">一个new_handler就是一个例子。

有与realloc（）等效的东西？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

当然可以使用realloc（）。</font><font style="vertical-align: inherit;">但是，只能保证realloc（）在malloc（）（和类似函数）分配的数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

。

yle="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
 style="vertical-align: inherit;">您如何报告错误？</font><font style="vertical-align: inherit;">您抛出异常。</font><font style="vertical-align: inherit;">这就是

></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（资源获取即初始化）的基础，它是一些最有效的现代C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

le="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
班级来说，结果会更糟。</font><font style="vertical-align: inherit;">至少，我们将不得不写：

没有bad（）; </font><font style="vertical-align: inherit;">它依赖于异常</font></font><font></font><font style="vertical-align: inherit;"><font style="vergn: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

换，但要依靠动态检查。</font><font style="vertical-align: inherit;">这将需要对v成员的每次访问进行运行时检查，并且h（）在遇到v的最后一个元素时必须抛出异常。

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

 &lt;&lt; s &lt;&lt;'\ n';</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

ont></a>

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>





资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">im + = a.im; </font><font style="vertical-align: inherit;">返回* this; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

>

herit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

ruct F {//对象创建函数的接口</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

（假设Java可能会重载+）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font styl IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

increasingly sporadic.

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

delete-zero">

www.stroustrup.com/bs_faq2.html#resume">

me after catching an exception?</a>

-operator">

+ i++?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

: inherit;">

s.html">my publications list</a>.

 format.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

e, the user need not be concerned with the allocation and

ements<font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

align: inherit;">

ertical-align: inherit;">

tical-align: inherit;">

align: inherit;">

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

This is sometimes known as the "brittle base class problem."

</p><p>

The obvious solution is to omit the "information helpful to implemeters" for

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如果确实存在某些所有派生类（或仅几个派生类）共有的信息怎么办？</font><font style="vertical-align: inherit;">只需将该信息作为一个类并从中派生实现类即可：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Shape {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

//与Shapes用户的界面</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font>tical-align: inherit;">

tical-align: inherit;">//需要打开一个文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font></font>

="vertical-align: inherit;">

记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font>
<a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

: inherit;">异常安全性：概念和技术”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

t></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

gn: inherit;">资源获取，即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（有时缩写为RAII），该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

nt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

）; </font><font style="vertical-align: inherit;">//打开名为“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

草率思考，并导致过多的运行时检查。

ical-align: inherit;"><font style="vertical-align: inherit;">

必须被堆分配为多态的；</font><font style="vertical-align: inherit;">这意味着内存和访问成本。</font><font style="vertical-align: inherit;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

ertical-align: inherit;">

重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
"vertical-align: inherit;">

 inherit IPv4:0.0.0.0
 IPv6:::
begin make socket
begin bind
perpare to serve
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

s.html">publications</a>

html">WG21 papers</a>

"http://www.stroustrup.com/videos.html">videos</a>

increasingly sporadic.

general FAQ</a>.

s</a>:

uctors?</a>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

q2.html#generics">

 been?</a>

l>

>

"memory">Memory</a>:

www.stroustrup.com/bs_faq2.html#resume">

;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

e, the user need not be concerned with the allocation and

tion of memory for vector elements.

>

ing in strings, see

ements<font></font>

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

for C++) and don't use ten-year-old

商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

This is sometimes known as the "brittle base class problem."

t;">

lign: inherit;">

herit;">

l-align: inherit;">

="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

/font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

>

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

cal-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
tical-align: inherit;">

用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论



align: i接口。

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

崩溃。

<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

tyle="vertical-align: inherit;">

<font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

理由inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

且有效的容器。</font><font style="vertical-align: inherit;">示例包括矢量，列表和地图：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

-align: inherit;">

ont style="vertical-align: inherit;">

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

来删除“拥有的”对象）。

 no

 good hash function,

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，clude &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

nt style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

的X的指针分配给p1。

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p3，a3）;</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

个Arena跟踪它持有的对象，您甚至可以编写destroy（）来保护自己免受错误的侵害。

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

：

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 no

 good hash function,

X＆）可以访问X :: i * /}</font></fon;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

al-align: inherit;">

"vertical-align: inherit;">

tyle="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">但是，我们不必为每次获取资源都使用“ finally”子句。</font><font style="vertical-align: inherit;">在现实的系统中，资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

TC ++ PL 14.4.2。

到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

ical-align: inherit;">

应该打印一个0指针，后跟一个非0指针。</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	p 0x0 q 0x378d0

nherit;">

it;"><font style="vertical-align: inherit;">



ertical-align: inherit;">

al-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

t></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
rtical-align: inherit;">什么</font><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">指向统一存储。

型的一组初始化程序作为其参数；</font><font style="vertical-align: inherit;">它返回一个指向其类型的（可选）初始化对象的指针。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

: inherit;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

le="vertical-align: inherit;">

"vertical-align: inherit;">//分配1个初始化为0的int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">//分配1个未初始化的int</font></font><font></font>

t;"><font style="vertical-align: inherit;">

10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-ae="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

<font style="vertical-align: inherit;">那将是一团糟。

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

 no

 good hash function,

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><fon所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{删除p; </font><font style="vertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

">

cal-align: inherit;">

ical-align: inherit;">

align: inherit;">	无效f（int a []，int s）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="verti为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//更好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

更容易理解。</font><font style="vertical-align: inherit;">也就是说，incr1（）更可能导致错误和错误。</font><font style="vertical-align: inherit;">因此，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

"><font style="vertical-align: inherit;">我确实想更改参数，应该使用指针还是应该使用引用？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

，具有很大的滥用和错误可能性，并且在几乎所有情况下，都有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

">

cal-align: inherit;">

ical-align: inherit;">

align: inherit;">	无效f（int a []，int s）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

style="vertical-align: inherit;">

>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

lign: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

yle="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

<h2><a name="null"><font style=此，“对构造函数的调用”不能是虚拟的。

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

gn: inherit;">

">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">只要该类具有至少一个虚函数。</font><font style="vertical-align: inherit;">具有虚函数表示类旨在充当派生类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

>

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f2：很好，我们继承了Base :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

t;">

herit;">实际上，仅具有纯虚函数的类通常称为接口。

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

vertical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D :: f。</font><font style="vertical-align: inherit;">考虑如果规则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运
行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

gn: inherit;">

">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

不同类型的元素nherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

ign: inherit;">

配给合适的指针。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

tyle="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

rit;">

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

t;">

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
style="vertical-align: inherit;">

ertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

al-align: inherit;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

ont style="vertical-align: inherit;">

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

gn: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

如：

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

n: inherit;">

rtical-align: inherit;">。

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

建到变量名称中可能会有所帮cal-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我应该使用NULL还是0？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

在C ++中，NULL的定义为0，因此仅存在美学差异。</font><font style="vertical-align: inherit;">我更喜欢避免使用宏，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数
。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">基本上，在C和C ++中，如果在表达式中读取了两次变量（在该变量中也写入了变量），则结果是不确定的。</font><font style="vertical-align: inherit;">不要那样做 </font><font style="vertical-align: inherit;">另一个示例是：

的，单独的和未充分使用的工具。

现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

困难。

lign: inherit;">

herit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-alig"vertical-align: inherit;"><font style="vertical-align: inherit;">

我应该使用NULL还是0？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

在C ++中，NULL的定义为0，因此仅存在美学差异。</font><font style="vertical-align: inherit;">我更喜欢避免使用宏，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数
。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">因此，不同的实现会做不同的事情。</font><font style="vertical-align: inherit;">不幸的是，我所知道的最好的解释是在一本书中，而这本书已经过时，并且没
描述任何当前的C ++实现：

"vertical-align: inherit;">第二章有一个非常简短的解释

"vertical-align: inherit;">另一个示例是：

现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

我可能会写类似： 

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误lign: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过返回0报告内存耗尽。 

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
t><font style="vertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

><font style="vertical-align: inherit;">考虑：

font></font><font></font>

font style="vertical-align: inherit;">/ *不安全，合法的C，而不是C ++ * /</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">因此，在C ++中，要从void *获取T *，您需要进行显式转换。</font><font style="vertical-align: inherit;">例如，要获得上述程序的不良影响，您必须编写：

>		int * pp =（int *）q;

cmplx;</font></font><font></font>

乍一看，c1的声明似乎更简洁，但请注意，要使用类内初始化语法，常量必须是通过常量表达式初始化的整数或枚举类型的静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ame="delete-zero"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不删除其操作数为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font 如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

</font></font><p>

The second frequently occuring genuine performance problem is the use of a map&lt;string,X&gt; for

a large number of (string,X) pairs.

 no

 good hash function,

rtical-align: inherit;">

l-align: inherit;">

ertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</pre>

<p>



</p><hr>

<h2><a name="call-by-reference"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我应该使用按值致电还是按引用致电？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

更容易理解。</font><font style="vertical-align: inherit;">也就是说，incr1（）更可能导致错误和错误。</font><font style="vertical-align: inherit;">因此，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

值/状态时，我们经常使用成员函数。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

">

cal-align: inherit;">

style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

好的解释是在一本书中，而这本书已经过时，并且没
描述任何当前的C ++实现：

功能的类的每个对象添加指t><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

rit;"><font style="vertical-align: inherit;">

herit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

为在某些情况下，这样可以更轻松地发现可能进行修改。 

法，而不是（后来的）Smalltalk对“ self”的用法。

">

cal-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

"vertical-align: inherit;">另一个示例是：

++）;

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器不同，并且因为C留下了许多不确定的东西。</font><font style="vertical-align: inherit;">对于细节，包括术语“未定义”，“未指定”，“实现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

n: inherit;">进行范围检查会增加运行有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

emoving an element). For std::list with the

nt. For small elements where the copy overhead is not

 allocator. Use a hand-crafted intrusive lists only

rmance is needed.

rtical-align: inherit;">

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 :: m（）{i ++; </font><font style="vertical-align: inherit;">/ * X :: m（）可以访问X :: i * /}</font></font><font></font>

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

ical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">



C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

虑：

值/状态时，我们经常使用成员函数。

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></n: inherit;">

-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 b）{a == b; </font><font style="vertical-align: inherit;">a！= b; </font><font style="vertical-align: inherit;">a &lt;b; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;int，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，int&gt;（）;</font></font><font></font>

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（vector &lt;Record&gt;＆vs）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

同）。</font><font style="vertical-align: inherit;">例如：

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

herit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

</pre>

<p>

inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

为在某些情况下，这样可以更轻松地发现可能进行修改。 

值/状态时，我们经常使用成员函数。

">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p>

</p><hr>

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

"vertical-align: inherit;">另一个示例是：

现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

，性能问题是理论上的还是虚构的：首先进行测量，然后仅在需要时进行优化。

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

 no

 good hash function,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

emoving an element). For std::list with the

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

l-align: inherit;">

ertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{删除p; </font><font style="vertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;style="vertical-align: inherit;">但是，C ++不能保证。

"vertical-align: inherit;"><font style="vertical-align: inherit;">



nt><font style="vertical-align: inherit;">}

rit;"><font style="vertical-align: inherit;">	void fct（）//难看，容易出错且效率低下</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	int main（int argc，char * argv []）{/ * ... * /}

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

能会提供main（）的更多版本，但是它们都必须具有返回类型int。</font><font style="vertical-align: inherit;">main（）返回的int是程序将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

rtical-align: inherit;">

 inherit;">

font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的
</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertic
al-align: inherit;">尚不清楚这种并发症会带来什么好处。 

vertical-align: inherit;">（点）原则上可以使用与-&gt;相同的技术来重载。</font><font style="vertical-align: inherit;">但是，这样做可能会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	Y类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

</pre> 

font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

tical-align: inherit;">

t;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪
决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

字符串</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function 助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">
助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><l助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<li="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bnk type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

l-align: inherit;">

“魔术”更难发现。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

辑的。

a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't th（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

herit;">

需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

困难。

t style="vertical-align: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

然，除非这些是属性）正在受约束测试）

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

align: inherit;">

东西-不在语言中？

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

ont><font style="vertical-align: inherit;">从那时起，出现了许多使这些约束类易于编写并仍然触发良好错误消息的想法。</font><font style="vertical-align: inherit;">例如，我相信使用指针来实现Can_copy中的功能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

erit;"><font style="vertical-align: inherit。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p3，a3）;</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

个Arena跟踪它持有的对象，您甚至可以编写destroy（）来保护自己免受错误的侵害。

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

vertical-align: inherit;">

类（例如，确保我可以复制对象而不必担心切片） 

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

类容器，因为它们在绝大多数情况下最容易使用，可提供最佳的编译时错误消息，并且不会造成不必要的运行时开销。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

>

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

t style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></fo少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

l-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

检测器，或插入垃圾收集器。

上下文。</font><font style="vertical-align: inherit;">为使代码正确无误，引发问题的作者和渔获物的作者需要彼此熟悉代码和上下文。</font><font style="vertical-align: inherit;">这造成了一个复杂的相互依赖关系，无论在哪里允许它都会导致严重的维护问题。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

/font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strupfont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

"vertical-align: inherit;">第二章有一个非常简短的解释

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

的，单独的和未充分使用的工具。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

t style="vertical-align: inherit;">

我可能会写类似： 

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="ver.com/except.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常安全性：概念和技术”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

nt style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

nherit;">	苹果类：公共水果{void apple_fct（）; </font><font style="vertical-align: inherit;">/ * ... * /};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例妿译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

困难。

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

herit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

it;">

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 b）{a == b; </font><font style="vertical-align: inherit;">a！= b; </font><font style="vertical-align: inherit;">a &lt;b; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

>

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

同）。</font><font style="vertical-align: inherit;">例如：

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可s_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

<a href="http://www.stroustrup.com/bs_faq2.html#arrays">

What's wrong with arrays?</a>

q2.html#exceptions-what-not">



时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

inherit;">这是使用标准库的标准ISO C ++程序。</font><font style="vertical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

 not have to depend on. For example, many

be logically independent of the definition

information changes), and ex例如，“无法通过double *初始化Shape *” ”）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

标准库auto_ptr），可以清楚地知道责任在哪里：

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inhernt>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

">

;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></p><p>





</p><hr>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

tyle="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

ont><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码it;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



tical-align: inherit;">

;"><font style="vertical-align: inhe
What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

</a>

reference">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

译为“控制台应用程序”。</font><font style="vertical-align: inherit;">请记住给源文件加上.cpp后缀，否则编译器可能会认为它是C（不是C ++）源。

ont style="vertical-align: inherit;">

tream state" in your C++ textbook.

n't have to count elements.

for reading in strings, see

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">How do I read a string from input?</a>.

ly more

end":

or string<font></font>

 style="vertical-align: inherit;">TC ++ PL4的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

e="vertical-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

herit;">有

ideos"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

形状{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

const;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

ation that are

otected part changes, users of Shape have to

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

nherit;">

inherit;">

vertical-align: inherit;">考虑：

ef="http://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

正确内联简单的操作。</font><font style="vertical-align: inheri
t;">真正的本地对象和内联是使复杂程序的性能接近内置复杂cess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

t;">

lign: inherit;">

gn: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

rit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-al<font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">。

/font><p>

align: inherit;">	// C ++代码</font></font><font></font>

 inherit;">

/ 单程</font></font><font></font>

 inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

nherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t style="vertical-align: inherit;">

虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

<font></font>

>	/ * C代码：* /</font></font><font></font>

="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">}</font></font><font></font>

rtical-align: inherit;">另一方面，C ++非常注重类型。

向C（和C ++）声明语法为风格的正确性。</font><font style="vertical-align: inherit;">实际上，*绑定到语法中的名称p。



为每个声明声明一个名称可以最大程度地减少问题-尤其是在我们初始化变量时。</font><font style="vertical-align: inherit;">人们写的可能性要小得多：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * p =＆i;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">请参见

"vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

有时称为“ Stroustrup”样式。</font><font style="vertical-align: inherit;">例如：

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

纳。</font><font style="vertical-align: inherit;">将函数的左括号放在新行上有助于我一眼就将函数定义与类定义区分开。



的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
 inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">	the_number_of_elements个剩余的_free_slots_in_symbol_table

stplacement"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

之前还是之后加上“ const”吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

但是那是个品味问题。</font><font style="vertical-align: inherit;">“ const T”和“ T const”分别是-和-都是允许的，并且是等效的。</font><font style="vertical-align: inherit;">例如：

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;">

初命名为“ readonly”，并具有一个相应的“ writeonly”）时，我允许它在类型之前或之后使用，因为我可以这样做而不会产生歧义。</font><font style="vertical-align: inheri更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

ont></font>

 inherit;">

有泄漏？

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

l-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ents”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/except.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常安全性：概念和技术”</font></font></a><font rit;">

cal-align: inherit;"><font style="vertical-align: inherit;">C ++编程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

lign: inherit;">

进行了优化以反映该假设。

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">这与常见的不安全用法相反：

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

“ use f”部分抛出异常-或只是返回了-文件不会关闭。</font><font style="vertical-align: inherit;">在C程序中，longjmp（）是另外一个危险。

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

nherit;">	苹果类：公共水果{void apple_fct（）; </font><font style="vertical-align: inherit;">/ * ... * /};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
align: inherit;">下载该文件。

ont></a>

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>





</p><hr>

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vtical-align: inherit;">

in（），vec.end（））;

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

">

;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
lign: inherit;">您抛出异常。</font><font style="vertical-align: inherit;">这就是

">（资源获取即初始化）的基础，它是一些最有效的现代C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 b）{a == b; </font><font style="vertical-align: inherit;">a！= b; </font><font style="vertical-align: inherit;">a &lt;b; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

ont></font>

t style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

;">

检测器，或插入垃圾收集器。

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: i快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

lign: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

herit;"><font style="vertical-align: inherit;">

m/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取，即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（有时缩写为RAII
，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

换，但要依靠动态检查。</font><font style="vertical-align: inherit;">这将需要对v成员的每次访问进行运行时检查，并且h（）在遇到v的最后一个元素时必须抛出异常。

vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

ont></a>

l-align: inherit;">来自析构函数？</font></font></a></h2>

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

</li><li>

arrays">

ustrup.com/bs_faq2.html#undefined">

 undefined in C++?</a>

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

素</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“元素顺序相反：\ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		for（int i = 0; i &lt;v.size（）; ++ i）cout &lt;&lt; v [i] &lt;&lt;'\ n';</font></font><font></font>

nt></font>

t>

<font></font>

erit;"><font style="vertical-align: inherit;">

鼓励人们将C ++用作

align: inherit;">

ertical-align: inherit;">

Color in the definition of Shape will probably

les defining the operating system's notion of

This is sometimes known as the "brittle base class problem."

</p><p>

The obvious solution is to omit the "information helpful to implemeters" for

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

从中派生实现类即可：

style="vertical-align: inherit;">

 inherit;">

;"><font style="vertical-align: inherit;">

 inherit;">

"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">考虑：

-align: inherit;"><font style="vertical-align: inherit;">

接口的类中。</font><font style="vertical-align: inherit;">而是将其放在派生类中。</font><font style="vertical-align: inherit;">看，</font></font><a href="http://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: i，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

 &lt;&lt; s &lt;&lt;'\ n';</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。



灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>





</p><hr>

l-align: inherit;">来自析构函数？</font></font></a></h2>

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

></font>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inheritnherit;">

;">

oint（0,0），10）; </font><font st">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是例外很昂贵！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： 并不是的。</font><font style="vertical-align: inherit;">现代C ++实现将使用异常的开销减少了百分之几（例如3％），这与没有错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

SF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

gn: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

Apple的Orange。

;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

nherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inheriign: inherit;">

herit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

rtical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

</p><hr>

<h2><a name="placement-delete"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是否有“展示位置删除”？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font>

/font>

itialize image from file<font></font>

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f使用文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处">例如：

</pre>

<p>



值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

style="vertical-align: inherit;">

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

vertical-align: inherit;"><font style="vertical-align: inherit;">

道其大小，因此无法分配数组：

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

"vertical-align: inherit;">另一个示例是：

的，单独的和未充分使用的工具。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

困难。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	tere an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

ements<font></font>

nt></font>

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

 not have to depend on. For example, many

be logically independent of the definition

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

接口的类中。</font><font style="vertical-align: inherit;">而是将其放在派生类中。</font><font style="vertical-align: inherit;">看，</font></font><a href="http://www.ststyle="vertical-align: inherit;"><font style="vertical-align: inherit;">。

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

 my_sqrt（-1）; </font><font style="vertical-align: inherit;">//发生错误时返回-1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

t>

cal-align: inherit;">my_negate（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



tical-align: inherit;">

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

herit;"><font style="vertical-align: inherit;">

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

都提供某种形ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

ustrup.com/bs_faq2.html#exceptions">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

1; </font><font style="vertical-align: inherit;">//错误返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

</font></font><font></font>

 inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

tical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

住给源文件加上.cpp后缀，否则编译器可能会认为它是C（不是C ++）源。

tains no explicit memory management, and it does not

 input?</a>.

，v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

顺序相反：\ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;v.size（）; ++ i）cout &lt;&lt; v [i] &lt;&lt;'\ n';</font></font><font></font>

: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

n many examples that

tandard.

商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

nherit;">

e presence of "information helpful to implementers" in the base class

o acts as the interface to users is the source of instability in the

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">

</font>

示非常简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

nherit;">

gn: inherit;">

align: inherit;">

语言所必需的。

因为许多类并未设计为用作基类。</font><font style="vertical-align: inherit;">例如，参见</font></font><a href="http://www.stroustrup.com/bs_faq2.html#data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

 inherit;">

由“ const”全局替换为“ readonly”而创建的（对我而言）。

<font style="vertical-align: inherit;">

font style="vertical-align: inherit;">例如，这是什么意思？：

</font><font style="vertical-align: inherit;">也许x和y是标量变量，并且（T）表示值转换。</font><font style="vertical-align: inherit;">也许x是从y的类派生的类，而（T）是垂头丧气的。</font><font style="vertical-align: inherit;">也许x和y是不相关的指针类型。</font><font style="vertical-align: inherit;">因为可以使用C样式转换（T）来表示许多逻辑上不同的操作，所以编译器只有抓住错误的机会。</font><font style="vertical-align: inherit;">出于同样的原因，程序员可能不完全知道强制转换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

转换”，使程序员有机会更清楚地陈述其意图，并使编译器捕获更多错误。</font><font style="vertical-align: inherit;">例如：

换回其原始类型。

ts really are mostly avoidable

因。</font><font style="vertical-align: inherit;">因此，C ++提供了更适合其他C ++的替代方法，例如内联函数，模板和名称空间。

</font><font></font>

写了一个称为“ alpha”的宏或一个称为“ beta”的宏，则可能无法编译或（更糟糕的）编译成意外的东西。</font><font style="vertical-align: inherit;">例如，“ someheader.h”可能包含：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#define alpha'a'</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

efine前缀get_ready（）; </font><font style="vertical-align: inherit;">int ret__</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">转到出口</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

n: inherit;">

		Return（x ++）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		后缀;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

传递的规则。</font><font style="vertical-align: inherit;">例如：

e="vertical-align: inherit;">	＃定义平方（x）（x * x）</font></font><font></font>

l-align: inherit;">

rit;">即（d + d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">

似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

/font><a href="https://www.chu.cam.ac.uk/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剑桥丘吉尔学院</font></font></a>

tml">Programming</a>

mp;E</a>

</a>

middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?<e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a he;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stro这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 &lt;int&gt; vi;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">

herit;">

 no

 good hash function,

widely

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

herit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

">

style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p>

</p><hr>

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我应该使用NULL还是0？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

在C ++中，NULL的定义为0，因此仅存在美学差异。</font><font style="vertical-align: inherit;">我更喜欢避免使用宏，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数
。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

"vertical-align: inherit;">第二章有一个非常简短的解释

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</foni>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

www.stroustrup.com/bs_faq2.html#finally">

provide a "finally" construct?</a>

ustrup.com/bs_faq2.html#static-cast">

?</a>

素</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		for（int i = 0; i &lt;v.size（）; ++ i）cout &lt;&lt; v [i] &lt;&lt;'\ n';</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">这是使用标准库的标准ISO C ++程序。</font><font style="vertical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

e="vertical-align: inherit;">

ected type/format).

ate" in your C++ textbook.

>

ing in strings, see

"http://www.stroustrup.com/bs_faq2.html#read-string">How do I read a string from input?</a>.

uidelines.md"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

cal-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

有

商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

tical-align: inherit;">

align: inherit;">

"><font style="vertical-align: inherit;">

al-align: inherit;">

从中派生实现类即可：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Shape {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

//与Shapes用户的界面</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

>

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Empty {};</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

</li><li>

eatures</a>:

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

for C++) and don't use ten-year-old

好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

herit;">

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="verticaobject?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

</li><li>

eatures</a>:

q2.html#cout">

 use call-by-value or call-by-reference?</a>

>

"http://www.stroustrup.com/bs_faq2.html#constplacement">

 put "const" before or after the type?</a>

l>

herit;"><font style="vertical-align: inherit;">

简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

align: inherit;"><font style="vertical-align: inherit;">

编译器可能会认为它是C（不是C ++）源。

</font><a href="http://www.stroustrup.com/bs_faq2.html#void-main"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

li><li>

elements.

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

] &lt;&lt;'\ n';</font></font><font></font>

导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

nt><a href="http://www.stroustrup.com/C++.html#videos"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

tandard is to provide a set of rules for using

le="vertical-align: inherit;">我不能帮你解决这些问题。

但是，您尝试编译的程序很可能设计不当，因此编译该程序时，编译器将检查数百个头文件和数万行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

考虑一下面向对象程序的经典示例：

"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

source of instability in the

ode (when implementation

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

形状{</font></font;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
cal-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

ont></a>

nt style="vertical-align: inherit;">

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

//www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>

vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></p><p>

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font stynherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

it;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
tyle="vertical-align: inherit;"
="vertical-align: inherit;">

font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

cal-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

-align: inherit;">

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

SF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

“ use f”部分抛出异常-或只是返回了-文件不会关闭。</font><font style="vertical-align: inherit;">在C程序中，longjmp（）是另外一个危险。

rit;"><font style="vertical-align: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下ertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>



e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

 inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅仅是从函数返回值的替代方法（类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">这样做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

;">

nherit;">

font><font style="vertical-align: inherit;">不幸的是，您不能为数组指定它。</font><font style="vertical-align: inherit;">通常，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

;">malloc（）时，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都必须考虑将返回指针初始化和转换为适当的类型。</font><font style="vertical-align: inherit;">您还必须考虑是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><fo型的语言所必需的。

ss complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

当派生类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

r"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

拟构造函数？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">因此，“对构造函数的调用”不能是虚拟的。

font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

”的变体。</font><font style="vertical-align: inherit;">关键是user（）与AX和AY等类的知识完全隔离。

tical-align: inherit;">例如：

l-align: inherit;"><font style="vertical-align: inherit;">

		//没有f2：很好，我们继承了Base :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		无效f3（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">

e="vertical-align: inherit;">	Base :: f3（）{/ * ... * /}

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

由以下示例提示：

n（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">它永远不会打扰B的（封闭）作用域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><
font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">//使B中的每个f都可用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

yle="vertical-align: inherit;">

造函数中，虚拟调用机制被禁用，因为尚未发生从派生类的重写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

al-align: inherit;"><font style="vertical-align: inherit;">

\ n”; </font><font style="vertical-align: inherit;">f（ss）; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

相同：仅使用局部定义-不会调用覆盖函数，以避免触及对象的（现已销毁）派生类部分。

n: inherit;"><font style="vertical-align: inherit;">

正确删除这些对象？</font><font style="vertical-align: inherit;">没有内置的“展示位置删除”来匹配新的展示位置的原因是，没有确保其正确使用的通用方法。</font><font style="vertical-align: inherit;">C ++类型系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位
分配的X的指构函数的容器来删除“拥有的”对象）。

</font></font><p>

The second frequently occuring genuine performance problem is the use of a map&lt;string,X&gt; for

a large number of (string,X) pairs.

Maps are fine for relatively small containers

 no

 good hash function,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

l-align: inherit;">

font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

t;My_type&gt; r：-新的My_type;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

描述任何当前的C ++实现：

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

ign: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">

n: inherit;">进行范围检t><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

ign: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

困难。

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

herit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

align: inherit;">

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font stnherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

</font><font style="vertical-align: inherit;">只要该类具有至少一个虚函数。</font><font style="vertical-align: inherit;">具有虚函数表示类旨在充当派生类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

ont style="vertical-align: inherit;">	班级基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

herit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		B * q = fac.make_a_B（）; </font><font style="vertical-align: inherit;">//制作适当类型的B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f2：很好，我们继承了Base :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f3（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

3会覆盖Base :: f3</font></font><font></font>

t;">

herit;">实际上，仅具有纯虚函数的类通常称为接口。

cal-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

erit;">或

t;"><font style="vertical-align: inherit;">

f（）函数的重载集怎么办？</font><font style="vertical-align: inherit;">使用using声明很容易做到：

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

样使用“ new”吗？</font></font></a></h2>

-align: inherit;"><font style="vertical-align: inherit;">

地做，通常会有更好的选择。</font><font style="vertical-align: inherit;">考虑：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无效计算（cmplx z，double dyle="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

rtical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

类型。</font><font style="vertical-align: inherit;">您还必须考虑是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

tical-align: inherit;">

 inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

ign: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

可以在常量表达式中使用的常量（例如，作为数组绑定），则有两种选择：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

tyle="vertical-align: inherit;">

;">

rtical-align: inherit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

中并不流行。

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font styl/a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

arrays">

www.stroustrup.com/bs_faq2.html#finally">

provide a "finally" construct?</a>

 undefined in C++?</a>

ustrup.com/bs_faq2.html#static-cast">

它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

al-align: inherit;">

		cout &lt;&lt;“元素顺序相反：\ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		for（int i = 0; i &lt;v.size（）; ++ i）cout &lt;&lt; v [i] &lt;&lt;'\ n';</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		返回0; </font><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以下是有关该程序的一些观察结果：

</font></font><ul>

<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是使用标准库的标准ISO C ++程序。</font><font style="vertical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tion of memory for vector elements.

>

t>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

标准库简单地完成简单操作的更多示例，请参见</font></font><a href="http://www.stroustrup.com/4th.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL4的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

鼓励人们将C ++用作

rtical-align: inherit;"><font style="vertical-align: inherit;">

商的设计中，那ustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

</li><li>

What's wrong with arrays?</a>

</li></ul>





</li><li>



"http://www.stroustrup.com/bs_faq2.html#callC">

 call a C function from C++?</a>

>

"http://www.stroustrup.com/bs_faq2.html#callCpp">

 call a C++ function from C?</a>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">这是使用标准库的标准ISO C ++程序。</font><font style="vertical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

机上进行编译，则需要将其编译为“控制台应用程序”。</font><font style="vertical-align: inherit;">请记住给源文件加上.cpp后缀，否则编译器可能会认为它是C（不是C ++）源。

			string s;<font></font>

			cin &gt;&gt; s;		// look for terminator string<font></font>

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL4的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

om/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

strup.com/resource-model.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

注点分离。

cal-align: inherit;">	类Shape {</font></font><font></ft;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

同样，具有虚拟功能的类的对象需要虚拟功能调用机制所需的空间-通常每个对象一个字。</font><font style="vertical-align: inherit;">这种开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

有关</font><font style="vertical-align: inherit;">更多设计依据，</font><font style="vertical-align: inherit;">请参见

 </font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演进</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

style="vertical-align: inherit;">

</h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

B * make_a_B（）const = 0;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

style="vertical-align: inherit;">

 inherit;">

ign: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">//此用户进行AY和BY</font></font><font></font>

AY等类的知识完全隔离。

font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

yle="vertical-align: inherit;">

范围，找到单个函数“ double f（double）”并对其进行调用。</font><font style="vertical-align: inherit;">它永远不会打扰B的（封闭）作用域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

用于B的f（）和D的f（）以选择最合适的f（）进行调用。

al-align: inherit;"><font style="vertical-align: inherit;">

同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

>它可能无法达到您的期望。</font><font style="vertical-align: inherit;">在构造函数中，虚拟调用机制被禁用，因为尚未发生从派生类的重写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

tical-align: inherit;">

l-align: inherit;"> D :: f。</font><font style="vertical-align: inherit;">考虑如果规则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

已销毁）派生类部分。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

多详细信息，请参见

</font><a href="http://www.stroust的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

cal-align: inherit;">是一个以数字（字节）为参数的函数；</font><font style="vertical-align: inherit;">它返回一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指向统一存储。

vertical-align: inherit;">是一个运算符，它使用一个类型和（可选）该类型的一组初始化程序作为其参数；</font><font style="vertical-align: inherit;">它返回一个指向其类型的（可选）初始化对象的指针。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

构造函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;">

nherit;">

ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

tical-align: inherit;">

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

;">

tyle="vertical-align: inherit;">

rit;">

1;</font></font><font></font><font styleyle="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

in（），vec.end（））;

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">

align: inherit;">

ont><font></font>

t style="vertical-align: inherit;">

 inherit;">

们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

l-align: inherit;">

">

;">

上下文。</font><font style="vertical-align: inherit;">为使代码正确无误，引发问题的作者和渔获物的作者需要彼此熟悉代码和上下文。</font><font style="vertical-align: inherit;">这造成了一个复杂的相互依赖关系，无论在哪里允许它都会导致严重的维护问题。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

 my_sqrt（-1）; </font><font style="vertical-align: inherit;">//发生错误时返回-1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

t>

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
le="vertical-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

用析构函数。

"vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

ical-align: inherit;">例子：

rtical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

类型。</font><font style="vertical-align: inherit;">您还必须考虑是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
tical-align: inherit;">

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

herit;">

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-a式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
cal-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

 &lt;&lt; s &lt;&lt;'\ n';</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。



灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>

l-align: inherit;">来自析构函数？</font></font></a></h2>

inherit;">

函数中引发异常。</font><font style="vertical-align: inherit;">没有真正令人满意的替代方法，可以通过抛出异常退出构造函数。 

e="vertical-align: inherit;">

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</fon用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



tical-align: inherit;">

;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">C ++编程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

>

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font styt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

为什么我必须将数据放入类声明中？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

你不知道 </font><font style="vertical-align: inherit;">如果您不想在接口中使用数据，请不要将其放在定义接口的类中。</font><font style="vertical-align: inherit;">而是将其放在派生类中。</font><font style="vertical-align: inherit;">看，</font></font><a href="http://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

有时，您确实希望在类中具有表示数据。</font><font style="vertical-align: inherit;">考虑类复杂：

</font></font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class Scalar&gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	上市：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		complex（）：re（0），im（0）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		complex（标量r）：re（r），im（0）{}</font></font><font></fot style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

im; </font><font style="vertical-align: inherit;">返回* this; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

lign: inherit;"><font style="vertical-align: inherit;">

需要虚拟功能调用机制所需的空间-通常每个对象一个字。</font><font style="vertical-align: inherit;">这种开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

t;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

d被调用的虚拟析构函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

阅TC ++ PL3 15.6.2。

nt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

tical-align: inherit;">

le="vertical-align: inherit;">

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font>emplate &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

cal-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

>

即可使用它，并且他们不必为标准类型编写compare（）函数。

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

align: inherit;">

n: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

检测器，或插入垃圾收集器。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

问题时才进行检查然后抛出的函数。</font><font style="vertical-align: inherit;">一个new_handler就是一个例子。

 inherit;"><font style="vertical-align: inherit;">

数组上工作，这e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

tyle and Technique FAQ</h1>

delete-zero">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“元素顺序相反：\ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		for（int i = 0; i &lt;v.size（）; ++ i）cout &lt;&lt; v [i] &lt;&lt;'\ n';</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		返回0; </font><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以下是有关该程序的一些观察结果：

</font></font><ul>

<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是使用标准库的标准ISO C ++程序。</font><font style="vertical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如果要在Windows计算机上进行编译，则需要将其编译为“控制台应用程序”。</font><font style="vertical-align: inherit;">请记住给源文件加上.cpp后缀，否则编译器可能会认为它是C（不是C ++）源。

</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是的，</font></font><a href="http://www.stroustrup.com/bs_faq2.html#void-main"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

e, the user need not be concerned with the allocation and

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

鼓励人们将C ++用作

商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

 inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅仅是从函数返回值的替代方法（类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">这样做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

"vertical-align: inherit;">

;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inhnt style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

中：</font></font><font></font>

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

;">

tyle="vertical-align: inherit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

基本上，仅当您希望对象的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

"http://www.stroustrup.com/videos.html">videos</a>

"http://www.stroustrup.com/applications.html">applications</a>

"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

"http://www.stroustrup.com/compilers.html">compilers</a>

>



ref="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

>

="right">

 November 22, 2019

e questions about C++ Style and Technique that people ask me often.

ave better questions or comments on the answers,

s</a>:

q2.html#generics">

 been?</a>

q2.html#sort">

ort()"?</a>

q2.html#function-object">

q2.html#auto_ptr">

l>

www.stroustrup.com/bs_faq2.html#resume">

-operator">

+ i++?</a>

ustrup.com/bs_faq2.html#undefined">

>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

 not have to depend on. F行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
cal-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

ont></a>

rit;">不要这样

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

har * a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">如果（p）抛出Open_error（errno）; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f使用文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">幡示的实现方面。

yle="vertical-align: inherit;">

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

This is sometimes known as the "brittle base class problem."

l-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

;">

ont style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

ical-align: inherit;">。

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

>

herit;">

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

le="vertical-align: inherit;">

e="vertical-align: inherit;">

<font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

rtical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style=e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

increasingly sporadic.

general FAQ</a>.

">C++ glossary</a>.

www.stroustrup.com/bs_faq2.html#resume">

+ i++?</a>

ustrup.com/bs_faq2.html#undefined">

 undefined in C++?</a>

ustrup.com/bs_faq2.html#static-cast">

e">

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

ements<font></font>

al-align: inherit;">

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

andard C++.

好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

 not have to depend on. For example, many

be logically independent of the definition

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

This is sometimes known as the "brittle base class problem."

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

"vertical-align: inherit;"><font style="vertical-align: e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

uctors?</a>

om/bs_faq2.html#virtual-dtor">

by default?</a>

om/bs_faq2.html#pure-virtual">

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

q2.html#generics">

 been?</a>

www.stroustrup.com/bs_faq2.html#resume">

me after catching an exception?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

s.html">my publications list</a>.

ements<font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

 not have to depend on. For example, many

be logically independent of the definition

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

t;">

lign: inherit;">

gn: inherit;">

lign: inherit;">

>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

接口的类中。</font><font style="vertical-align: inherit;">而是将其放在派生类中。</font><font s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

崩溃。

rtical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

e="vertical-align: inherit;">        类竞技场{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

">

系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

herit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p3，a3）;</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

ont></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

tyle="vertical-align: inherit;">

且有效的容器。</font><font style="vertical-align: inherit;">示例包括矢量，列表和地图：

"><font style="vertical-align: inherit;">	vector &lt;int&gt; vi（10）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

：

-align: inherit;">

，性能问题是理论上的还是虚构的：首先进行测量，然后仅在需要时进行优化。

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 &lt;int&gt; vi;</font></font><font></font><font style="vertical-align: inherit;"><fontor example, many

be logically independent of the definition

Color in the definition of Shape will probably

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

This is sometimes known as the "brittle base class problem."

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

>

n: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

erit;">或

 inherit;">）。

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

（假设Java可能会重载+）</font></font><font></font><font style="vertical-align: inherit;"><f"vertical-align: inherit;"> 15.4.3。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

tyle="vertical-align: inherit;">

<font style="vertical-align: inherit;">

gn: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 &lt;int&gt; vi;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

s.html">publications</a>

html">WG21 papers</a>

tml">TC++PL</a>

p://www.stroustrup.com/bstechfaq.htm">Chinese</a>

Q&amp;A with annotations

="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

/a>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

q2.html#generics">

 been?</a>

delete-zero">

-operator">

+ i++?</a>

;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“元素顺序相反：\ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		for（int i = 0; i &lt;v.size（）; ++ i）cout &lt;&lt; v [i] &lt;&lt;'\ n';</font></font><font></font>

: inherit;">

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

鼓励人们将C ++用作

for C++) and don't use ten-year-old

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 not have to depend on. For example, many

be logically independent of the definition

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

>

n: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

t;">

herit;">实际上，仅具有纯虚函数的类通常称为接口。

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

f（）函数的重载集怎么办？</font><font style="vertical-align: inherit;">使用using声明很容易做到：

rit;"><font style="vertical-align: inherit;">	D级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

rtical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ ont style="vertical-align: inherit;">

ertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

rtical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

tical-align: inherit;">

e="vertical-align: inherit;">        类竞技场{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

cal-align: inherit;">数组</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

：

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><ftyle="vertical-align: inherit;">看，</font></font><a href="http://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

herit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

t style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

</p><hr>

<h2><a name="placement-delete"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">

e="vertical-align: inherit;">        类竞技场{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 e;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

uctors?</a>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

www.stroustrup.com/bs_faq2.html#resume">

-operator">

+ i++?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

: inherit;">

s.html">my publications list</a>.

 format.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

e, the user need not be concerned with the allocation and

ements<font></font>

nt></font>

t>

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

 not have to depend on. For example, many

be logically independent of the definition

Color in the definition of Shape will probably

les defining the operating system's notion of

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

l-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="ve术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如果确实存在某些所有派生类（或仅几个派生类）共有的信息怎么办？</font><font style="vertical-align: inherit;">只需将该信息作为一个类并从中派生实现类即可：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Shape {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

//与Shapes用户的界面</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

>

n: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: irtical-align: inherit;">

l-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

;"><font style="vertical-align: inherit;">

herit;">

rit;">

herit;">

>

">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">im + = a.im; </font><font style="vertical-align: inherit;">返回* this; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">只要该类具有至少一个虚函数。</font><font style="vertical-align: inherit;">具有虚函数表示类旨在充当派生类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

>

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font><= new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

al-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

口</font></font><font></font>

。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

>

l-align: inherit;">

font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

l-align: inherit;">

font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

</pre>

<p>

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

法，而不是（后来的）Smalltalk对“ self”的用法。

">

style="vertical-align: inherit;">

>

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

功能的类的每个对象添加指针（vptr）来PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

开销。

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

-align: inherit;">

ont style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

l-align: inherit;">

ertical-align: inherit;">

X＆）可以访问X :: i * /}</font></fonont style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.10和

l-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.5、15.3和C.11。

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

herit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//更好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>



</p><hr>

<h2><a name="call-by-reference"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></fonherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

（假设Java可能会重载+）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

崩溃。

rtical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

gn: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

的，单独的和未充分使用的工具。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

困难。

lign: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

t style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

t style="vertical-align: inherit;">

/font></font><font></font>

-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

it;">

it;">

）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//更好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为在某些情况下，这样可以更轻松地发现可能进行修改。 

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

&gt;＆b，整数大小）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

realloc（）在免费存储区中分配</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p>

</p><hr>

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

"vertical-align: inherit;">另一个示例是：

现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

rtical-align: inherit;">这意味着C ++必须处理硬件实体，例
位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">因此，不同的实现会做不同的事情。</font><font style="vertical-align: inherit;">不幸的是，我所知道的最好的解释是在一本书中，而这本书已经过时，并且没有描述任何当前的C ++实现：

"vertical-align: inherit;"><font style="vertical-align: inherit;">《带注释的C ++参考手册》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

的，单独的和未充分使用的工具。

定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

ut &lt;&lt; 1; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

以允许编译器产生最佳代码。</font><font style="vertical-align: inherit;">据称，可以给编译器带来这种自由的结果与要求“从左至右进行常规评估”之间的差异可能很大。</font><font style="vertical-align: inherit;">我不敢相信，但是随着无数的编译器“自由地”利用了自由，并且一些人热情地捍卫了这种自由，改变将是困难的，并且可能需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

><font style="vertical-align: inherit;"><font style="vertical-a提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

类容器，因为它们在绝大多数情况下最容易使用，可提供最佳的编译时错误消息，并且不会造成不必要的运行时开销。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

 no

 good hash function,

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

>

要的（对于C兼容性至关重要），但请考虑以下事项：

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;">//错误（由编译器报告）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

化程序和复制分配以提供所需的语义。

<font style="vertical-align: inherit;">

herit;">对于Point，默认的复制语义很好，问题出在构造函数上：

rit;"><font style="vertical-align: inherit;">	结构点{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

t style="vertical-align: inherit;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

;">//使用默认值（0,0）创建orig</font></font><font></font><font style="vertic/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

lign: inherit;">

的X的指针分配给p1。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;int，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

in（），vec.end（））;

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

>

t style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

内联应用程序运算符的函数对象可以内联精美，因为其中没有涉及可能使优化器混淆的指针。</font><font style="vertical-align: inherit;">相比之下：当前的优化器很少（从来没有）能够通过指向函数的指针来内联调用。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

检测器，或插入垃圾收集器。

上下文。</font><font style="vertical-align: inherit;">为使代码正确无误，引发问题的作者和渔获物的作者需要彼此熟悉代码和上下文。</font><font style="vertical-align: inherit;">这造成了一个复杂的相互依赖关系，无论在哪里允许它都会导致严重的维护问题。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

问题时才进行检查然后抛出的函数。</font><font style="vertical-align: inherit;">一个new_handler就是一个例子。

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的曠此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

困难。

lign: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;int，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

in（），vec.end（））;

事实通常很重要。</font><font style="vertical-align: inherit;">而且，sort（）是通用的，因此可以用于容器类型，元素类型和比较条件的任何合理组合。</font><font style="vertical-align: inherit;">例如：

{</font></font><font></font><font style="vertical-align: inheritt><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>



</p><hr>

<h2><a name="call-by-reference"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

e="vertical-align: inherit;">

用进行调用；</font><font style="vertical-align: inherit;">例如void f（const X＆）;

e="vertical-align: inherit;">

ical-align: inherit;">例如空f（X）;

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

更容易理解。</font><font style="vertical-align: inherit;">也就是说，incr1（）更可能导致错误和错误。</font><font style="vertical-align: inherit;">因此，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

">

style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

realloc（）在免费存储区中分配</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

="vertical-align: inherit;">

 inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

cal-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font slign: inherit;">

困难。

lign: inherit;">

t style="vertical-align: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

t style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

cal-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

it;">

初始化方式，是否可以复制，销毁对象等进行假设（当然，除非这些是属性）正在受约束测试）

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;int，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，int&gt;（）;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Can_compare &lt;int，float&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Can_compare &lt;X，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

类容器，因为它们在绝大多数情况下最容易使用，可提供最佳的编译时错误消息，并且不会造成不必要的运行时开销。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

itialize image from file<font></font>

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 &lt;int&gt; vi;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">

 no

 good hash function,

widely

 than (string,X) pairs,

 strings. Also, if X is large,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

rtical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{删除p; </font><font style="vertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

style="vertical-align: inherit;">这导致灾难：退出f（）时，将调用h1和h2的析构函数，并将h1.p和h2.p指向的对象删除两次。

erit;">

的解决方案是通过将复制操作设为私有来防止复制：

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;";"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

;">

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

/font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

tical-align: inherit;">

;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

gn: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

align: inherit;">下载该文件。

ont></a>

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

l-align: inherit;">来自析构函数？</font></font></a></h2>

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

 style="vertical-align: inherit;">}</font></font><font></font>

资源获取要比al-align: inherit;"><font style="vertical-align: inherit;">

rit;">//使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">//调用Point（2,0）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">然后，有些人对f（）的调用中2到Point（2,0）的转换感到惊讶。</font><font style="vertical-align: inherit;">带有单个参数的构造函数定义一个转换。</font><font style="vertical-align: inherit;">默认情况下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

"><font style="vertical-align: inherit;">	结构点{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

，y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

t style="vertical-align: inherit;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

;">//使用默认值（0,0）创建orig</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;">//使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">//错误（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">//错误（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">//好的（显式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

t;My_type&gt; r：-新的My_type;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

style="vertical-align: inherit;">

>

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style件，套接字等。

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

测试），有关</font><font style="vertical-align: inherit;">

例外的常见异议：

/font></p><ul>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是例外很昂贵！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： 并不是的。</font><font style="vertical-align: inherit;">现代C ++实现将使用异常的开销减少了百分之几（例如3％），这与没有错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

SF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

tical-align: inherit;">

;">例如：

lign: inherit;">

进行了优化以反映该假设。

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

“ use f”部分抛出异常-或只是返回了-文件不会关闭。</font><font style="vertical-align: inherit;">在C程序中，longjmp（）是另外一个危险。

>

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

align: inherit;">

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">因此，不同的实现会做不同的事情。</font><font style="vertical-align: inherit;">不幸的是，我所知道的最好的解释是在一本书中，而这本书已经过时，并且没有描述任何当前的C ++实现：

"vertical-align: inherit;"><font style="vertical-align: inherit;">《带注释的C ++参考手册》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

具有关键布局示例图。</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二章有一个非常简短的解释

tical-align: inherit;">

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">基本上，在C和C ++中，如果在表达式中读取了两次变量（在该变量中也写入了变量），则结果是不确定的。</font><font style="vertical-align: inherit;">不要那样做 </font><font style="vertical-align: inherit;">另一个示例是：

++）;

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

我可能会写类似： 

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；<align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

总和</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

ont><font></font>

t style="vertical-align: inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

ertical-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

">

;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

 my_sqrt（-1）; </font><font style="vertical-align: inherit;">//发生错误时返回-1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

t>

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



;">例如：

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

herit;"><font style="vertical-align: inherit;">

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vert>

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

rit;"><font style="vertical-align: inherit;">

herit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

">

cal-align: inherit;">

style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

vertical-align: inherit;"><font style="vertical-align: inherit;">

道其大小，因此无法分配数组：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void f（int a []，int b []，int size）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">//不是数组分配</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，size）; </font><font style="vertical-align: inherit;">// a = b</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

欢vector：

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void g（vector &lt;int&gt;＆a，vector &lt;int&gt;＆b，整数大小）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

另一个优点是memcpy（）不会对具有复制构造函数的元素（例如字符串）做正确的事情。

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void f（字符串a []，字符串b []，整数大小）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">//不是数组分配</font></font><font></font><font style="vertical-align: inherit;">

nherit;">	苹果类：公共水果{void apple_fct（）; </font><font style="vertical-align: inherit;">/ * ... * /};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

橙色没有apple_fct（）</font></font><font></font>

;">

</font></font><font></font>

gn: inherit;">

>

stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

++ PL3的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

并且通常要支付使用函数的虚拟函数调用和/或动态强制转换的费用​​。

结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

l#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

退出构造函数。 

不良情况，因为会违反标准库的基本规则和语言本身。</font><font style="vertical-align: inherit;">不要这样

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

;"><font style="vertical-align: inherit;">。

"vertical-align: inherit;"><font style="vertical-align: inherit;">。

，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

 inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码〄源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

会泄漏。</font><font style="vertical-align: inherit;">有关详细信息，请参见TC ++ PL 14.4.2。

tyle="vertical-align: inherit;">

l-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

ign: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

e="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

e="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-al="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

的，单独的和未充分使用的工具。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器不同，并且因为C留下了许多不确定的东西。</font><font style="vertical-align: inherit;">对于细节，包括术语“未定义”，“未指定”，“实现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

cal-align: inherit;"><font style="vertical-align: inherit;">

时）是否可以将T1分配给T2。</font><font style="vertical-align: inherit;">Can_copy &lt;T，Shape *&gt;检查T是Shape *还是指向从Shape公开派生的类的指针，或者是否是用户定义的转换为Shape *的类型的指针。</font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

尚未达成共识。

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="ver<font style="vertical-align: inherit;">

，size）; </font><font style="vertical-align: inherit;">//灾难</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

r &lt;string&gt;＆a，vector &lt;string&gt;＆b，整数大小）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

font><font></font>

>	const int S = 10;</font></font><font></font>

="vertical-align: inherit;">

 inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

align: inherit;">

nt style="vertical-align: inherit;">但是，数组衰减与继承的相互作用非常差。</font><font style="vertical-align: inherit;">考虑：

it;">	Base类{void fct（）; </font><font style="vertical-align: inherit;">/ * ... * /};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;">

 inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

tical-align: inherit;">

 inherit;">

vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我应该使用NULL还是0？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

在C ++中，NULL的定义为0，因此仅存在美学差异。</font><font style="vertical-align: inherit;">我更喜欢避免使用宏，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数
。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器不同，并且因为C留下了许多不确定的东西。</font><font style="vertical-align: inherit;">对于细节，包括术语“未定义”，“未指定”，“实现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

个正确的答案，如果不能令人满意的话。</font><font style="vertical-align: inherit;">与C一样，C ++旨在直接有效地利用硬件。</font><font style="vertical-align: inherit;">这意味着C ++必须处理硬件实体，例如位，字节，字，地址，整数计算/font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;">

。



herit;">而且，sort（）是通用的，因此可以用于容器类型，元素类型和比较条件的任何合理组合。</font><font style="vertical-align: inherit;">例如：

;"><font style="vertical-align: inherit;">

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

留0。例如：

cal-align: inherit;"><font style="vertical-align: inherit;">用作标准容器的成员。</font><font style="vertical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

ign: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><fo
nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

nherit;">

ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font styical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

 inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

align: inherit;">下载该文件。

ont></a>

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

har * a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">如果（p）抛出Open_error（errno）; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-a其接近于必要。

l-align: inherit;">

">

;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

恢复？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

供原始方法来返回引发异常的地方并从那里继续执行呢？

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-a浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

以允许编译器产生最佳代码。</font><font style="vertical-align: inherit;">据称，可以给编译器带来这种自由的结果与要求“从左至右进行常规评估”之间的差异可能很大。</font><font style="vertical-align: inherit;">我不敢相信，但是随着无数的编译器“自由地”利用了自由，并且一些人热情地捍卫了这种自由，改变将是困难的，并且可能需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

物”是未定义的，未指定的，实现定义的等等。但是，这很容易说，甚至给出示例，但很难解决。</font><font style="vertical-align: inherit;">还应注意，避免大多数问题并生成可移植代码并不是很困难。

lign: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vlign: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

tical-align: inherit;">

应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

“ use f”部分抛出异常-或只是返回了-文件不会关闭。</font><font style="vertical-align: inherit;">在C程序中，longjmp（）是另外一个危险。

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

gn: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

Apple的Orange。

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

ont></a>

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通tical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 b）{a == b; </font><font style="vertical-align: inherit;">a！= b; </font><font style="vertical-align: inherit;">a &lt;b; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

-align: inherit;"><font style="vertical-align: inherit;">

，为什么要使用sort（）？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

ont></font>

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

ertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

在标准开发过程中使用内存泄漏检测器，或插入垃圾收集器。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font stylign: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 



</p><hr>

<h2><a name="realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

;">

tyle="vertical-align: inherit;">

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

中并不流行。

>

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

al-align: inherit;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

in（），vec.end（））;

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

align: inherit;">

ont><font></font>

t style="vertical-align: inherit;">

象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

应用程序中需要的对象的一部分隐式处理分配/取消分配，则可以使用资源句柄来最大程度地减少泄漏的机会。</font><font style="vertical-align: inherit;">这是一个示例，我需要从函数返回在免费存储区上分配的对象。</font><font style="vertical-align: inherit;">这是一个忘记删除该对象的机会。</font><font style="vertical-align: inherit;">毕竟，我们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;内存&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

">

;">

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></p><p>

ents”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中lign: inherit;">并且将无法为最后n-1个X调用析构函数。

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

"vertical-align: inherit;">

;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

style="vertical-align: inherit;">

font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="v行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

 my_sqrt（-1）; </font><font style="vertical-align: inherit;">//发生错误时返回-1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-alignle="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

herit;">

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

可以在常量表达式中使用的常量（例如，作为数组绑定），则有两种选择：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

tyle="vertical-align: inherit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

中并不流行。

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

nherit;"><font style="vertical-align: inherit;">

f（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">例如：

ical-align: inherit;">} // X超过了g（）的调用</font></font><font></font>

）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><fe="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></p><p>





align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><fo</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

ign: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><fo
nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
cal-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

ont></a>

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

">《 JSF飞机C ++编码标准》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

har * a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>

></font><font></font><font style="vertical-it;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

"vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

如：

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">。

inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

</font><font style="vertical-align: in于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

ical-align: inherit;">例子：

;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

le="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

herit;">

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">	typedef std :: complex &lt;double&gt; cmplx;</font></font><font></font>

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

;">

tyle="vertical-align: inherit;">

是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="verticaertical-align: inherit;">

ont><font style="vertical-align: inherit;">//定义</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

nherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

基本上，仅当您希望对象的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ont></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f使用文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;">

yle="vertical-align: inherit;">通常，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

n: inherit;">都必须考虑将返回指针初始化和转换为适当的类型。</font><font style="vertical-align: inherit;">您还必须考虑是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

内存耗尽。 

引发异常来报告分配和初始化错误。

象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
tical-align: inherit;">

用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

"vertical-align: inherit;">

tyle="vertical-align: inherit;">需要调用构造函数或析构函数的位置。</font><font style="vertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

"vertical-align: inherit;">

虑使用标准库向量。</font><font style="vertical-align: inherit;">例如

e="vertical-align: inherit;">	//从输入中读取单词到字符串向量中：</font></font><font></font>

l-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

;</font></font><font></font>

: inherit;">

tical-align: inherit;">

讨论，您可以从我的</font></font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

e="vertical-align: inherit;">

2>

nherit;">

e="vertical-align: inherit;">这是不安全的。</font><font style="vertical-align: inherit;">考虑：

e="vertical-align: inherit;">	#include &lt;stdio.h&gt;</font></font><font></font>

l-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

，合l-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

t;"><font style="vertical-align: inherit;">

受（没有特殊的预防措施）。</font><font style="vertical-align: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

: inherit;"><font style="vertical-align: inherit;">

保证``指向已删除对象的任何指针都是0''。绕过``规则''的更简单方法是有两个指向对象的指针：

 inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">p = 0; </font><font style="vertical-align: inherit;">}

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">//错误：尝试通过非常量引用传递右值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">//错误：尝试通过非常量引用传递右值</font></font><font></font>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用析构函数？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

”，但请看一下经常伴随该问题的示例：

vertical-align: inherit;"><font style="vertical-align: inherit;">	无效f（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

的）假设，即“ new”创建的对象将在函数末尾销毁。

rtical-align: inherit;"><font style="vertical-align: inherit;">

的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	X * g（int i）{/ * ... * /返回新的X（i）; </font><font style="vertical-align: inherit;">} // X超过了g（）的调用</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

作用域中，请不要使用“ new”，而只需定义一个变量即可：

{/ * ... * /}

将值返回到调用它的“系统”的一种方式。</font><font style="verticalnt style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

SF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></p><p>

cal-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

用</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

lign: inherit;">auto_ptr保留一个指针，可用作指针，并删除其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

align: inherit;">	#include &lt;内存&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

“魔术”更难发现。

t>

lign: inherit;">

 inherit;"><font style="vertical-align: inherit;">

d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
herit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

“魔术”更难发现。

t>

lign: inherit;">

 inherit;"><font style="vertical-align: inherit;">

d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contrherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

“魔术”更难发现。

t>

lign: inherit;">

 inherit;"><font style="vertical-align: inherit;">

d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, uibuted to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="httnified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.cherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

“魔术”更难发现。

t>

lign: inherit;">

 inherit;"><font style="vertical-align: inherit;">

d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are membeherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

“魔术”更难发现。

t>

lign: inherit;">

 inherit;"><font style="vertical-align: inherit;">

d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

“魔术”更难发现。

t>

lign: inherit;">

 inherit;"><font style="vertical-align: inherit;">

d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtont style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

;">

nt style="vertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

al-align: inherit;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

ern“ C”''的函数。</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如：

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

会永远持续下去。</font><font style="vertical-align: inherit;">每个声明只使用一个指针，并且总是初始化变量，混乱的根源消失了。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">

</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

比任何特定样式都重要。</font><font style="vertical-align: inherit;">像大多数人一样，我很难为自己的喜好构建一个坚实的逻辑论据。

 Stroustrup”样式。</font><font style="vertical-align: inherit;">例如：

tical-align: inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

生歧义。</font><font style="vertical-align: inherit;">现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

ont style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		双dd = h（i，d）; </font><font style="vertical-align: inherit;">//错误：意外的参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

inherit;">

style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">通常，人们对代码布局的观点持坚决态度，但是一致性比任何特定样式都重要。</font><font style="vertical-align: inherit;">像大多数人一样，我很难为自己的喜好构建一个坚实的逻辑论据。

<font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">当为C中找不到的构造添加约定时，这有时称为“ Stroustrup”样式。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">C级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">在每种方案中，些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

cal-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

例外的常见异议：

/font></p><ul>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是例外很昂贵！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： 并不是的。</font><font style="vertical-align: inherit;">现代C ++实现将使用异常的开销减少了百分之几（例如3％），这与没有错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

/font></li><li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是在</font>ical-align: inherit;">

 inherit;">

t style="vertical-align: inherit;">

style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

 inherit;">

<font style="vertical-align: inherit;">

"vertical-align: inherit;">

al-align: inherit;">用作标准容器的成员。</font><font style="vertical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

ign: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

 inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 



</p><hr>

<h2><a name="realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可以混合使le="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

"vertical-align: inherit;">

;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
tical-align: inherit;">

用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

"vertical-align: inherit;">

tyle="vertical-align: inherit;">需要调用构造函数或析构函数的位置。</font><font style="vertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

"vertical-align: inherit;">

中：</font></font><font></font>

herit;">

gn: inherit;"><font style="vertical-align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

tyle="vertical-align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

以具有更大的灵活性：

rit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

受（没有特殊的预防措施）。</font><font style="vertical-alig
n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style=有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

容易引起麻烦。

rtical-align: inherit;"><font style="vertical-align: inherit;">

择受到本地样式规则的限制。</font><font style="vertical-align: inherit;">请记住，保持一致的风格通常比以您认为最好的方式做每个小细节更重要。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

它在类型之前或之后使用，因为我可以这样做而不会产生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

 p2 = reinterpret_cast&lt;double*&gt;(&amp;a);	// ok: I really mean it<font></font>

font>

nt c = 7;<font></font>

 = &amp;c;			// error<font></font>

 = (int*)&amp;c;		// ok (but *q2=2; is still invalid code and may fail)<font></font>

 = static_cast&lt;int*&gt;(&amp;c);	// error: static_cast doesn't cast away const<font></font>

 = const_cast&lt;int*&gt;(&amp;c);	// I really mean it<font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

法是，与需要reinterpret_cast的转换相比，static_cast允许的转换导致错误的可能性要小一些。</font><font style="vertical-align: inherit;">原则上，可以使用static_cast的结果而无需将其强制转换回其原始类型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型。

/font><p>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

t;">

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

="vertical-align: inherit;">有关更多详细信息，请参见

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

能带来的好处时。

t style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

">

vertical-align: inherit;">

it;">

"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t>

it;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

说``int * p;''或``int * p;''

-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

: inherit;">实际上，*绑定到语法中的名称p。

对于正确使用C ++的更高级部分非常重要。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

erit;">

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font stl-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

herit;">

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		B * q = fac.make_a_B（）; </font><font style="vertical-align: inherit;">//制作适当类型的B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

样使用“ new”吗？</font></font></a></h2>

-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

rtical-align法的C，而不是C ++ * /</font></font><font></font>

l-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：

gn: inherit;"><font style="vertical-align: inherit;">

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

tyle="vertical-align: inherit;">

将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

="vertical-align: inherit;">例如：

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

 inherit;">

t;">

ertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">例外是

align: inherit;">	。</font><font style="vertical-align: inherit;">（点）::？：sizeof

-align: inherit;">

herit;">我只是没有看到需要引入重载三元运算符的特殊情况。</font><font style="vertical-align: inherit;">注意，重载</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
ign: inherit;">

组中）依赖于它。</font><font style="vertical-align: inherit;">考虑：

cal-align: inherit;">	X a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;"><font style="vertical-align: inherit;">

;"><font style="vertical-align: inherit;">

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

ern“ C”''的函数。</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

函数（包括虚拟p://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

-operator">

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

s.html">my publications list</a>.

 format.

nt style="verticalual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

www.stroustrup.com/bs_faq2.html#arrays">

ustrup.com/bs_faq2.html#call-by-reference">

ue or call-by-reference?</a>

ustrup.com/bs_faq2.html#constplacement">

ore or after the type?</a>

空间std中声明，不带.h后缀。

行编译，则需要将其编译为“控制台应用程序”。</font><font style="vertical-align: inherit;">请记住给源文件加上.cpp后缀，否则编译器可能会认为它是C（不是C ++）源。

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

http://www.stroustrup.com/bs_faq2.html#void-main"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</li><li>

A vector knows its size, so I don't have to count elements.

</li><li>

Yes, I know that I could declare <i>i</i> to be a <iom/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

+ i++?</a>

ustrup.com/bs_faq2.html#undefined">

 undefined in C++?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font s单的一个
主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

om/bio.html">bio</a>

om/interviews.html">interviews</a>

om/videos.html">videos</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:
单的一个
主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

om/bio.html">bio</a>

om/interviews.html">interviews</a>

om/videos.html">videos</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

waiting for accept:
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href单的一个
主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

om/bio.html">bio</a>

om/interviews.html">interviews</a>

om/videos.html">videos</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroust单的一个
主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

om/bio.html">bio</a>

om/interviews.html">interviews</a>

om/videos.html">videos</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html单的一个
主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

om/bio.html">bio</a>

om/interviews.html">interviews</a>

om/videos.html">videos</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn'用C风格和C ++风格分配和释放吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是的，因为您可以在同一程序中使用malloc（）和new。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不可以，因为您无法使用malloc（）分配对象，也无法使用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

ical-align: inherit;"><font style="vertical-align: inherit;">

 *转换？</font></font></a></h2>

"><font style="vertical-align: inherit;">

转换为T *。</font><font style="vertical-align: inherit;">这是不安全的。</font><font style="vertical-align: inherit;">考虑：

 inherit;">

<font style="vertical-align: inherit;">例如，要获得上述程序的
不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

ign: inherit;">

配给合适的指针。</font><font style="vertical-align: inherit;">例如：

cal-align: inherit;">	int * p = malloc（sizeof（int））;

-align: inherit;">

;">

tyle="vertical-align: inherit;">

;">

rtical-align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">//定义</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

/font><font style="vertical-align: inherit;">这些示例可能很少见，但它们确实暗示不可能保证``指向已删除对象的任何指针都是0''。绕过``规则''的更简单方法是有两个指向对象的指针：

style="vertical-align: inherit;">	T * p =新的T;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

！</font></font><font></font>

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

nherit;"><font style="vertical-align: inherit;">

f（）</font></font><font></font><font 标准C和C ++对说明符施加的排序规则很少（如果有的话）。

但我不记得当时我看过哪种语言。

ign: inherit;">

使用暗示可能会出现类型错误或数字值被截断的情况。</font><font style="vertical-align: inherit;">如果在开发或维护期间更改了其中一种类型，那么即使看上去很无辜的演员也可能成为一个严重的问题。</font><font style="vertical-align: inherit;">例如，这是什么意思？：

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

*（x））/ *更好* /

lign: inherit;">但是，我没有改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

om/bio.html">bio</a>

class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
标准C和C ++对说明符施加的排序规则很少（如果有的话）。

但我不记得当时我看过哪种语言。

ign: inherit;">

使用暗示可能会出现类型错误或数字值被截断的情况。</font><font style="vertical-align: inherit;">如果在开发或维护期间更改了其中一种类型，那么即使看上去很无辜的演员也可能成为一个严重的问题。</font><font style="vertical-align: inherit;">例如，这是什么意思？：

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

*（x））/ *更好* /

lign: inherit;">但是，我没有改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

om/bio.html">bio</a>

class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a 标准C和C ++对说明符施加的排序规则很少（如果有的话）。

但我不记得当时我看过哪种语言。

ign: inherit;">

使用暗示可能会出现类型错误或数字值被截断的情况。</font><font style="vertical-align: inherit;">如果在开发或维护期间更改了其中一种类型，那么即使看上去很无辜的演员也可能成为一个严重的问题。</font><font style="vertical-align: inherit;">例如，这是什么意思？：

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

*（x））/ *更好* /

lign: inherit;">但是，我没有改善C ++宏的抱负。</font><font style="vertical-align: inherit;">相反，我建议使用C ++语言本身的功能，例如内联函数，模板，构造函数（用于初始化），析构函数（用于清理），异常（用于退出上下文）等。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

om/bio.html">bio</a>

class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Cr functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

+ i++?</a>

ustrup.com/bs_faq2.html#undefined">

 undefined in C++?</a>

ustrup.com/bs_faq2.html#static-cast">

?</a>

ustrup.com/bs_faq2.html#macro">

ing macros?</a>

;">

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

uidelines.md"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

cal-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a>且将无法为最后n-1个X调用析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

what-not"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用什么？</font></font></a></h2><font style="vertical-align: inherit;lign: inherit;">

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

;">

nherit;">

。

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font stual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

此操作的示例程序：

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

inherit;">这是使用标准库的标准ISO C ++程序。</font><font style="vertical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

e="vertical-align: inherit;">

控制台应用程序”。</font><font style="vertical-align: inherit;">请记住给源文件加上.cpp后缀，否则编译器可能会认为它是C（不是C ++）源。

e="vertical-align: inherit;">

oid-main"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit"vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

中并不流行。

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ont></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><e="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">//错误：尝试通过非常量引用传递右值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

nherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

style="vertical-align: inherit;">

ertical-align: inherit;">

="vertical-align: inherit;">有关更多详细信息，请参见

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以像这样使用C :: f（）：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

如：



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">。

inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

for C++) and don't use ten-year-old

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="verlass hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

+ i++?</a>

ustrup.com/bs_faq2.html#undefined">

 undefined in C++?</a>

ustrup.com/bs_faq2.html#static-cast">

?</a>

ustrup.com/bs_faq2.html#macro">

ing macros?</a>

and style</a>:

ustrup.com/bs_faq2.html#cout">

ut"?</a>

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

 format.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

ritname="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

+ i++?</a>

;">

>

: inherit;">

inherit;">这是使用标准库的标准ISO C ++程序。</font><font style="vertical-align: inherit;">标准库工具在标头的名称空间std中声明，不带.h后缀。

e="vertical-align: inherit;">

控制台应用程序”。</font><font style="vertical-align: inherit;">请记住给源文件加上.cpp后缀，否则编译器可能会认为它是C（不是C ++）源。

e="vertical-align: inherit;">

oid-main"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ements<font></font>

nt></font>

t>

g<font></font>

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">//错误返回</font></font><font></font><font style="vertical-align: inhestyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

，将指针隐式地增加到数组中）依赖于它。</font><font style="vertical-align: inherit;">考虑：

gn: inherit;"><font style="vertical-align: inherit;">	X a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">// </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p指向a [4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

n: inherit;"><font style="vertical-align: inherit;">因此，p的整数yle="vertical-align: inherit;">p指向a [4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

的名称，::进行（编译时）范围解析，而不是表达式求值。</font><font style="vertical-align: inherit;">可以想象允许x :: y重载，其中x是对象而不是名称空间或类，但是-与第一次出现相反，这涉及引入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

。</font><font style="vertical-align: inherit;">但是，这样做可
会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

al-align: inherit;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font sroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

崩溃。

<font style="vertical-align: inherit;">那将是一团糟。

系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

gn: inherit;">

：

从Syle="vertical-align: inherit;"><font style="vertical-align: inherit;">

严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

则很少（如果有的话）。

ign: inherit;">

源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

 p2 = reinterpret_cast&lt;double*&gt;(&amp;a);	// ok: I really mean it<font></font>

font>

nt c = 7;<font></font>

 = &amp;c;			// error<font></font>

 = (int*)&amp;c;		// ok (but *q2=2; is still invalid code and may fail)<font></font>

 = static_cast&lt;int*&gt;(&amp;c);	// error: static_cast doesn't cast away const<font></font>

 = const_cast&lt;int*&gt;(&amp;c);	// I really mean it<font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">这通常是引起细微而不是细微问题的原因。</font><font style="vertical-align: inherit;">因此，C ++提供了更适合其他C ++的替代方法，例如内联函数，模板和名称空间。

herit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不能假设其他程序员始终如一地避免您认为“非常愚蠢”的事情。</font><font style="vertical-align: inherit;">例如，最近有人告诉我，他们遇到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#define前缀get_ready（）; </font><font style="vertical-align: inherit;">int ret__</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

i）ret __ = i; </font><font style="vertical-align: inherit;">做点什么（）; </font><font style="vertical-align: inherit;">转到出口</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

om/bio.html">bio</a>

om/interviews.html">interviews</a>

om/videos.html">videos</a>

om/applications.html">applications</a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

有

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

对象的地址不同。</font><font style="vertical-align: inherit;">由于相同的原因，“ new”总是返回指向不同对象的指针。</font><font style="vertical-align: inherit;">考虑：

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Empty {};</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

font><font style="vertical-align: inherit;">它允许程序员使用空类来表示非常简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

 inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

接口的类中。</font><font style="vertical-align: inherit;">而是将其放在派生类中。</font><font style="vertical-align: inherit;">看，</font></font><a href="http://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

t;">

al-align: inherit;"><font style="vertical-align: inherit;">

ref="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

</li><li>

What's wrong with arrays?</a>

</li></ul>





;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

ements<font></font>

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

andard C++.

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

 not have to depend on. For example, many

be logically independent of the definition

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">tyle="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

标准库简单地完成简单操作的更多示例，请参见</font></font><a href="http://www.stroustrup.com/4th.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL4的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

 not have to depend on. For example, many

be logically independent of the definition

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

This is sometimes known as the "brittle base class problem."

rit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

对象的地址不同。</font><font style="vertical-align: inherit;">由于相同的原因，“ new”总是返回指向不同对象的指针。</font><font style="vertical-align: inherit;">考虑：

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Empty {};</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="verticayle="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

;">

ont style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

font><font style="vertical-align: inherit;">它允许程序员使用空类来表示非常简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

 inherit;"><font style="vertical-align: inherit;">

/font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">im + = a.im; </font><font style="vertical-align: inherit;">返回* this; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确

font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

="vertical-align: inherit;">

font><font style="vertical-align: inherit;">它允许程序员使用空类来表示非常简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

/font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;">因此，“对构造函数的调用”不能是虚拟的。

le="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

体。</font><font style="vertical-align: inherit;">关键是user（）与AX和AY等类的知识完全隔离。

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f2：很好，我们继承了Base :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">）。

rit;"><font style="vertical-align: inherit;">	D级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（假设Java可能会重载+）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

中，虚拟调用机制被禁用，因为尚未发生从派生类的重写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

herit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 </font><font style="vertical-align: inherit;">f（ss）; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D :: f。</font><font style="vertical-align: inherit;">考虑如果规则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

</li><li>

>

: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

ements<font></font>

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

 not have to depend on. For example, many

be logically independent of the definition

Color in the definition of Shape will probably

les defining the operating system's notion of

t;">

lign: inherit;">

gn: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

rit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align:rup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

;">

herit;">

素</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

s.html">my publications list</a>.

 format.

rit;">

l-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

好，更易于维护，因为它们表现出更好的关注点分离。

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

 not have to depend on. For example, many

be logically independent of rup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

nt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font>

“展示位置删除”来匹配新的展示位置的原因是，没有确保其正确使用的通用方法。</font><font style="vertical-align: inherit;">C ++类型系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">

拟函数调用，则可能会问为什么这些函数首先是虚拟的。</font><font style="vertical-align: inherit;">我看到了一些示例，其中没有充分的理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

t;"><font style="vertical-align: inherit;">

止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;"> 

型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

使用（公共）对象接口发现元素的真实类型。

的编译时错误消息，并且不会造成不必要的运行时开销。

建一个容器。</font><font style="vertical-align: inherit;">例如：

神话和红色鲱鱼之一）：

nted as a container of pointers to X.

alues, and copy a value when you put it into the container.

 values, but can be quite unsuitable for huge objects:

，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解
方案：

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

_back（7）; </font><font style="vertical-align: inherit;">//将7的一个副本放入vi</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 directly (an int does not have a link member).

every element type. The standard-library list

copy for each operation inserting an element

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	X类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

可以访问X :: i * /}</font></font><font></font>

</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.5、15.3和C.11。

vertical-align: inherit;"> 为什么我不希望编译器复制我的对象？

rit;"><font style="vertical-align: inherit;"> 如何关闭复印？

ri-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

uidelines.md"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

cal-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

有

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

andard C++.

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

;">

ont style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">	结构X：空{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

	无效用户（cot C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

Why doesn't delete zero out its operand?</a>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

s.html">my publications list</a>.

ements<font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

at are

ected members

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

gn: inherit;">

ont style="vertic数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

说``int * p;''或``int * p;''

-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

: inherit;">实际上，*绑定到语法中的名称p。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

faces</a>,

esent errors,

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

way const<font></font>

t;">

转换导致错误的可能性要小一些。</font><font style="vertical-align: inherit;">原则上，可以使用static_cast的结果而无需将其强制转换回其原始类型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

t></font><font></font><font style="vertical-align: inherit;"><font stylerit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

;">

e="vertical-align: inherit;">

*（x））/ *更好* /

），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 



class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:
数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

说``int * p;''或``int * p;''

-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

: inherit;">实际上，*绑定到语法中的名称p。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

faces</a>,

esent errors,

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

way const<font></font>

t;">

转换导致错误的可能性要小一些。</font><font style="vertical-align: inherit;">原则上，可以使用static_cast的结果而无需将其强制转换回其原始类型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

t></font><font></font><font style="vertical-align: inherit;"><font stylerit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

;">

e="vertical-align: inherit;">

*（x））/ *更好* /

），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 



class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templat数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

说``int * p;''或``int * p;''

-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

: inherit;">实际上，*绑定到语法中的名称p。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

faces</a>,

esent errors,

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

way const<font></font>

t;">

转换导致错误的可能性要小一些。</font><font style="vertical-align: inherit;">原则上，可以使用static_cast的结果而无需将其强制转换回其原始类型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

t></font><font></font><font style="vertical-align: inherit;"><font stylerit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

;">

e="vertical-align: inherit;">

*（x））/ *更好* /

），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 



class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

说``int * p;''或``int * p;''

-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

: inherit;">实际上，*绑定到语法中的名称p。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

faces</a>,

esent errors,

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

way const<font></font>

t;">

转换导致错误的可能性要小一些。</font><font style="vertical-align: inherit;">原则上，可以使用static_cast的结果而无需将其强制转换回其原始类型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

t></font><font></font><font style="vertical-align: inherit;"><font stylerit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

;">

e="vertical-align: inherit;">

*（x））/ *更好* /

），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 



class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
waiting for accept:


<!-- saved from url=(0048)http://www.stroustrup.com/bs_faq2.html#void-main -->

<html class="translated-ltr"><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/prompt.js"></script><script src="chrome-extension://ljdobmomdgdljniojadhoplhkpialdid/page/runScript.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title> Stroustrup: C++ Style and Technique FAQ </title>

<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Stroustrup_ C++ Style and Technique FAQ_files/translateelement.css"></head>

<body bgcolor="FFFBFB" data-gr-c-s-loaded="true">

<center>

<a href="http://www.morganstanley.com/">Morgan Stanley</a>

|

<a href="http://www.cs.columbia.edu/">Columbia University</a>

|

<a href="https://www.chu.cam.ac.uk/">Churchill College, Cambridge</a>







</center>

<p>

</p><center>

<a href="http://www.stroustrup.com/index.html">home</a>

|

<a href="http://www.stroustrup.com/C++.html">C++</a>

|

<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>

|

<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>

|

<a href="http://www.stroustrup.com/papers.html">publications</a>

|

<a href="http://www.stroustrup.com/WG21.html">WG21 papers</a>

|

<a href="http://www.stroustrup.com/4th.html">TC++PL</a>

|

<a href="http://www.stroustrup.com/tour2.html">Tour++</a>

|

<a href="http://www.stroustrup.com/programming.html">Programming</a>

|

<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>

|

<a href="http://www.stroustrup.com/bio.html">bio</a>

|

<a href="http://www.stroustrup.com/interviews.html">interviews</a>

|

<a href="http://www.stroustrup.com/videos.html">videos</a>

|

<a href="http://www.stroustrup.com/applications.html">applications</a>

|

<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">guidelines</a>

|

<a href="http://www.stroustrup.com/compilers.html">compilers</a>

</center>

<center>

<h1><a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>'s C++ Style and Technique FAQ</h1>

</center>

<p align="right">

Modified November 22, 2019

</p><p>

These are questions about C++ Style and Technique that people ask me often.

If you have better questions or comments on the answers,

feel free to email me (bs at cs dot tamu dot edu).

Please remember that I can't spend all of my time improving my homepages.

</p><p>

I have contributed to the new, unified,

<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>

maintained by

<a href="http://isocpp.org/about">The C++ Foundation</a>

of which I am a director.

The maintenance of this FAQ is likely to become increasingly sporadic.

</p><p>

For more general questions, see my 

<a href="http://www.stroustrup.com/bs_faq.html">general FAQ</a>.

</p><p>

For terminology and concepts, see my

<a href="http://www.stroustrup.com/glossary.html">C++ glossary</a>.

</p><p>

Please note that these are just a collection of questions and answers. They are not

a substitute for a carefully selected sequence of examples and explanations

as you would find in a good textbook. Nor do they offer detailed and precise

specifications as you would find in a reference manual or the standard.

See

<a href="http://www.stroustrup.com/dne.html"> The Design and Evolution of C++</a> for questions

related to the design of C++.

See <a href="http://www.stroustrup.com/3rd.html">The C++ Programming Language</a> for questions

about the use of C++ and its standard library.

</p><p>

Translations:

</p><ul>

<li><a href="http://www.stroustrup.com/bstechfaq.htm">Chinese</a>

of some of this Q&amp;A with annotations

</li><li><a href="http://www.stroustrup.com/bsfaq2cn.html">another Chinese version</a>

</li><li><a href="http://www.forallworld.com/c-stilusu-es-technika-gyik/">Hungarian</a>

</li><li><a href="http://www.libjingu.jp/trans/bs_faq2-j.html">Japanese</a>

</li><li><a href="http://clipart-library.com/bjarne-stroustrups-c-style.html">Ukrainian</a>

</li></ul>

<p>

</p><ul>

<li>Topics:

<ul>

<li><a href="http://www.stroustrup.com/bs_faq2.html#start">Getting started</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#classes">Classes</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#hierarchies">Hierarchy</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#templates">Templates and generic programming</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#memory">Memory</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#exceptions-i">Exceptions</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#other">Other language features</a>

</li><li><a href="http://www.stroustrup.com/bs_faq2.html#trivia">Trivia and style</a>

</li></ul>



<p>

</p></li><li>

<a name="start">Getting started</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#simple-program">

How do I write this very simple program?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#coding-standard">

Can you recommend a coding standard?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#read-string">

How do I read a string from input?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#int-to-string">

How do I convert an integer to a string?</a>

</li></ul>



</li><li>

<a name="classes">Classes</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#layout-obj">

How are C++ objects laid out in memory?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#this">

Why is "this" not a reference?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty">

Why is the size of an empty class not zero?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#in-class">

How do I define an in-class constant?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-scope">

Why isn't the destructor called at the end of scope?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#friend">

Does "friend" violate encapsulation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#explicit-ctor">

Why doesn't my constructor work right?</a>

</li></ul>



</li><li>

<a name="hierarchies">Class hierarchies</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#abstract-class">

Why do my compiles take so long?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#data-in-class">

Why do I have to put the data in my class declarations?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual">

Why are member functions not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor">

Why don't we have virtual constructors?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#virtual-dtor">

Why are destructors not virtual by default?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pure-virtual">

What is a pure virtual function?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#final">

Why doesn't C++ have a final keyword?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#vcall">

Can I call a virtual function from a constructor?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#no-derivation">

Can I stop people deriving from my class?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#object">

Why doesn't C++ have a universal class Object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#multiple">

Do we really need multiple inheritance?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#overloadderived">

Why doesn't overloading work for derived classes?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a 参见</font></font><a href="http://www.stroustrup.com/bs_faq2.html#data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

个对象一个字。</font><font style="vertical-align: inherit;">这种开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

>

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AY源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">} // BY是从B派生的</font></font><font></font>tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

体。</font><font style="vertical-align: inherit;">关键是user（）与AX和AY等类的知识完全隔离。

vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

</font></font></p><p><font.html#new-java">

Can I use "new" just as in Java?</a>

</li></ul>





</li><li>

<a name="templates">Templates and generic programming</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#constraints">

Why can't I define constraints for my template parameters?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#conversion">

Why can't I assign a vector&lt;Apple&gt; to a vector&lt;Fruit&gt;?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#generics">

Is "generics" what templates should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

How do I call a C++ function from C?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pointers-and-references">

Why does C++ have both pointers and references?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#null">

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“元素顺序相反：\ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		for（int i = 0; i &lt;v.size（）; ++ i）cout &lt;&lt; v [i] &lt;&lt;'\ n';</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-alig>vector&lt;double&gt;::size_type</i>

rather than plain <i>int</i> to quiet

terminates input with the word "end":

nt>

标准库游览”一章

e="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

al-align: inherit;"><font style="vertical-align: inherit;"> 

t;"><font style="vertical-align: inherit;">。

 shared aspects of the implementation that are

lasses. For that reason, the set of protected members

s far more often than the public interface.

 "center" is arguably a valid concept for all Shapes,

 to maintain a point "center" for a Triangle - for

he base class

ility in the

entation

user code

eaders).

emeters" for

rit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

: inherit;">

ical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

t;">只需将该信息作为一个类并从中派生实现类即可：

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

共{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inheriont style="vertical-align: inherit;">

t;">

lign: inherit;">

编译器供应商报告错误”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">

al-align: inherit;">

</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

新的AY（）; </font><font style="vertical-align: inherit;">} // AY源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n new BY（）; </font><font style="vertical-align: inherit;">} // BY是从B派生的</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><hr>

<h2><a name="pure-virtual"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

什么是纯虚函数？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">	Base :: f3（）{/ * ... * /}

l-align: inherit;"><font style="vertical-align: inherit;">

一些简单的通用实现细节），但是在某些派生类中仍必须重写Base :: f3（）。

lign: inherit;"><font style="vertical-align: inherit;">

数，则该派生类将变为抽象：

ical-align: inherit;"><font style="vertical-align: inherit;">	D2类：公共基地{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ase :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

象的</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

n: inherit;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

醅联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

/font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

n: inherit;"><font style="vertical-align: inherit;">

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

it;">

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

f（）函数的重载集怎么办？</font><font style="vertical-align: inherit;">使用using声明很容易做到：

rit;"><font style="vertical-align: inherit;">	D级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<ftyle="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

 inherit;"><font style="vertical-align: inherit;">

h2><font style="vertical-align: inherit;"><font style="vertical-align: i
nherit;">

gn: inherit;">

: inherit;">

;">

gn: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以像这样使用C :: f（）：

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">

t;">

如：

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

：

n: inherit;">

rtical-align: inherit;">。

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

在无类型语言中很有用的技术，但完全不适用于支持通用编程和面向对象编程的语言-两者都强调选择基于参数类型的操作（语言或运行时支持已知）。</font><font style="vertical-align: inherit;">在这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

淆的名称。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	名字名字nameS</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

n: inherit;"><font style="vertical-align: inherit;">

容易引起麻烦。

</font></font><pre><font style="vertical-align: inherit;"><font styl;">

l-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

uidelines.md"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

cal-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

有

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

andard C++.

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

rit;">

: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 not have to depend on. For example, many

be logically independent of the definition

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

ex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

rit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">TC ++ PL4的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inher
it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

 not have to depend on. For example, many

be logically independent of the definition

Color in the definition of Shape will probably

t;">

lign: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

>

n: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

t style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声 inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

>

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数tical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

align: inherit;">

ertical-align: inherit;">

tical-align: inherit;">

align: inherit;">

t;">

lign: inherit;">

gn: inherit;">

lign: inherit;">

>

nherit;">

it;">

inherit;">

>

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

n: inherit;"><font style="vertical-align: inherit;">

erit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		A * p = fac.make_an_A（）; </font><font style="vertical-align: inherit;">//制作适当类型的A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		B * q = fac.make_a_B（）; </font><font style="vertical-align: inherit;">//制作适当类型的B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inhe为“纯”。</font><font style="vertical-align: inherit;">例如：

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f2：很好，我们继承了Base :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f3（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

; </font><font style="vertical-align: inherit;">//好的：派生的:: f3会覆盖Base :: f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

对于定义接口非常有用。</font><font style="vertical-align: inherit;">实际上，仅具有纯虚函数的类通常称为接口。

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">	B构
函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

e="vertical-align: inherit;">        类竞技场{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><fnst F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

it;">

 inherit;">

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的基础”。

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

<font style="vertical-align: inherit;">那将是一团糟。

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

类（例如，确保我可以复制对象而不必担心切片） 

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

gn: inherit;">

cal-align: inherit;">数组</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

nt><font style="vertical-align: inherit;">如果希望容器包含几种不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

 </font><font style="vertical-align: inherit;">//形状的指针向量

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

-align: inherit;">

ont style="vertical-align: inherit;">

，性能问题是理论上的还是虚构的：首先进行测量，然后仅在需要时进行优化。

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

</p><hr>

<h2><a name="placement-delete"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

 no

 good hash function,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

it;">

ign: inherit;">例如：

 inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">



t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

崩溃。

tical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style=href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

eatures</a>:

How do I call a C++ function from C?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#pointers-and-references">

Why does C++ have both pointers and references?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#null">

Should I use NULL or 0?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#evaluation-order">

What's the value of i++ + i++?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#undefined">

Why are some things left undefined in C++?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#static-cast">

;">

>

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		reverse（v.begin（），v.end（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

标准库简单地完成简单操作的更多示例，请参见</font></font><a href="http://www.stroustrup.com/4th.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL4的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “标准库游览”一章

yle="vertical-align: inherit;">。

r>

ing-standard"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

码标准吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++核心准则</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font s调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

gn: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

类容器，因为它们在绝大多数情况下最容易使用，可提供最佳的编译时错误消息，并且不会造成不必要的运行时开销。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

异构容器，请为所有元素定义一个通用接口，并为这些元素创建一个容器。</font><font style="vertical-align: inherit;">例如：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

 vio; </font><font style="vertical-align: inherit;">//如果您想直接管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

o_obj&gt;&gt; v2; </font><font style="vertical-align: inherit;">//如果您想要“智能指针”来处理对象</font></font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	vector &lt;void *&gt;内存；</font><font style="vertical-align: inherit;">//很少需要

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

别太低”的一个好兆头是您的代码中有大量的强制转换。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

以使用Any类（例如Boost :: Any）替代方法：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	vector &lt;Any&gt; v;

ners"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么慢？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inthe definition

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

l-align: inherit;">

="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">只要该类具有至少一个虚函数。</font><font style="vertical-align: inherit;">具有虚函数表示类旨在充当派生类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

n: inherit;"><font style="vertical-align: inherit;">

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

n: inherit;">它鼓励人们将C ++用作

for C++) and don't use ten-year-old

好，更易于维护，因为它们表现出更好的关注点分离。

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

yle="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

lign: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

;">

ont style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#realloc">

Can I mix C-style and C++ style allocation and deallocation?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#void-ptr">

Why must I use a cast to convert from void*?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">

Is there a "placement delete"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#delete-zero">

How do I call a C++ function from C?</a>

</li><li>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

herit;">

素</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">

lign: inherit;">main（）返回一个int</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

s.html">my publications list</a>.

 format.

ended by finding end-of-file

ected type/format).

ate" in your C++ textbook.

 to count elements.

ements<font></font>

nt></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

鼓励人们将C ++用作

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常
好，更易于维护，因为它们表现出更好的关注点分离。

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

 not have to depend on. For example, many

be logically independent of the definition

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

This is sometimes known as the "brittle base class problem."

l-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vee="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

ertical-align: inherit;">	int const c = 10;

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

从y的类派生的类，而（T）是垂头丧气的。</font><font style="vertical-align: inherit;">也许x和y是不相关的指针类型。</font><font style="vertical-align: inherit;">因为可以使用C样式转换（T）来表示许多逻辑上不同的操作，所以编译器只有抓住错误的机会。</font><font style="vertical-align: inherit;">出于同样的原因，程序员可能不完全知道强制转换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

 p2 = reinterpret_cast&lt;double*&gt;(&amp;a);	// ok: I really mean it<font></font>

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个
主要原因：人类和编译器会看到不同的事物。

="vertical-align: inherit;">

;">

e="vertical-align: inherit;">

l-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

om/bio.html">bio</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
（在许多变体中）通常由以下示例提示：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

yle="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">//使B中的每个f都可用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;">

"vertical-align: inherit;">在构造函数中，虚拟调用机制被禁用，因为尚未发生从派生类的重写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

{cout &lt;&lt;“ B构造函数\ n”; </font><font style="vertical-align: inherit;">f（ss）; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ing＆）{cout &lt;&lt;“ B :: f \ n”;}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">s = ss; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">

ical-align: inherit;">

l-align: inherit;">考虑如果规则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

函数的行为与构造函数相同：仅使用局部定义-不会调用覆盖函数，以避免触及对象的（现已销毁）派生类部分。

t style="vertical-align: inherit;">

-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

>

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

al-align: inherit;"><font style="vertical-align: inherit;">

e_t sz，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，虚拟函数调用是如此之快，以至于与使用普通函数调用的替代解决方案相比，它们在现实中对使用虚拟函数设计的类的使用不会产生可测量的运行时开销。</font><font style="vertical-align: inherit;">注意，虚函数调用机制通常仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

f（）覆盖;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

&gt; l2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，记录*&gt; tbl;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ector &lt;Record *&gt;&gt; t2;</font></font><font></font>

font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

"><font style="vertical-align: inherit;">	vector &lt;void *&gt;内存；</font><font style="vertical-align: inherit;">//很少需要

;"><font style="vertical-align: inherit;">

您的代码中有大量的强制转换。

font style="vertical-align: inherit;"><font style="vertical-align: inht style="vertical-align: inherit;">例如，请参阅TC ++ PL3 15.6.2。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

erit;">或

 inherit;">）。

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p3，a3）;</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

个Arena跟踪它持有的对象，您甚至可以编写destroy（）来保护自己免受错误的侵害。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为类层次结构</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

<font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">另请参阅

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></fonont style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

l-align: inherit;">

font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="verticont style="vertical-align: inherit;">那将是一团糟。

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

且有效的容器。</font><font style="vertical-align: inherit;">示例包括矢量，列表和地图：

"><font style="vertical-align: inherit;">	vector &lt;int&gt; vi（10）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

来删除“拥有的”对象）。

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="v）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

inherit;"><font style="vertical-align: inherit;">	结构点{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">通常，这正是您想要的（对于C兼容性至关重要），但请考虑以下事项：

inherit;"><font style="vertical-align: inherit;">	类句柄{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">//导致灾难！</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

= h1.name和h2.p == h1.p。</font><font style="vertical-align: inherit;">这导致灾难：退出f（）时，将调用h1和h2的析构函数，并将h1.p和h2.p指向的对象删除两次。

herit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">最简单的解决方案是通过将复制操作设为私有来防止复制：

gn: inherit;"><font style="vertical-align: inherit;">	类句柄{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

样使用“ new”吗？</font></font></a></h2>

-align: inherit;"><font style="vertical-align: inherit;">

地做，通常会有更好的选择。</font><font style="vertical-align: inherit;">考虑：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无效计算（cmplx z，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">// c ++样式</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

写。</font><font style="vertical-align: inherit;">对象是从头开始构造的，即“派生之前的基础”。

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

rtical-align: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

且有效的容器。</font><font style="vertical-align: inherit;">示例包括矢量，列表和地图：

"><font style="vertical-align: inherit;">	vector &lt;int&gt; vi（10）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font"vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

al-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

-align: inherit;">

，性能问题是理论上的还是虚构的：首先进行测量，然后仅在需要时进行优化。

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

</font></font><p>

The second frequently occuring genuine performance problem is the use of a map&lt;string,X&gt; for

a large number of (string,X) pairs.

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

rtical-align: inherit;">

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

t;My_type&gt; r：-新的My_type;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

类（例如，确保我可以复制对象而不必担心切片） 

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

 no

 good hash function,

eld for every element therit;">大概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

 no

 good hash function,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.10和

l-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.5、15.3和C.11。

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

>

l-align: inherit;">

font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>



</p><hr>

<h2><a name="call-by-reference"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我应该使用按值致电还是按引用致电？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

e="vertical-align: inherit;">

用进行调用；</font><font style="vertical-align: inherit;">例如void f（const X＆）;

e="vertical-align: inherit;">

ical-align: inherit;">例如空f（X）;

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

值/状态时，我们经rtical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

;">

ont style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

font><font style="vertical-align: inherit;">它允许程序员使用空类来表示非常简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

erit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆盖纯虚拟Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font styal-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

t;My_type&gt; r：-新的My_type;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

法，而不是（后来的）Smalltalk对“ self”的用法。

">

cal-align: inherit;">

ical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

>	const int S = 10;</font></font><font></font>

="vertical-align: inherit;">

 inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

的，单独的和未充分使用的工具。

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
困难。

herit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

align: inherit;">

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

>

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="veont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

gn: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

且有效的容器。</font><font style="vertical-align: inherit;">示例包括矢量，列表和地图：

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

</font></font><p>

 no

 good hash function,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </
么了？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

和空间而言，数组恰好是访问内存中对象序列的最佳构造。</font><font style="vertical-align: inherit;">但是，它也是一个非常低级的数据结构，具有很大的滥用和错误可能性，并且在几乎所有情况下，都有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

两个基本问题是

/font></p><ul>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;
">

style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

vertical-align: inherit;"><font style="vertical-align: inherit;">

道其大小，因此无法分配数组：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void f（int a []，int b []，int size）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">//不是数组分配</font></fontl-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p>

</p><hr>

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//更好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

</pre>

<p>



inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

为在某些情况下，这样可以更轻松地发现可能进行修改。 

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

style="vertical-align: inherit;">

>

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

功能的类的每个对象添加指针（vptr）t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

-align: inherit;">

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

 no

 good hash function,

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{删除p; </font><font style="vertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

l-align: inherit;">

font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font sterit;">

入式）列表比std :: list快得多

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

请考虑是否存在真正的性能问题。</font><font style="vertical-align: inherit;">在大多数情况下，性能问题是理论上的还是虚构的：首先进行测量，然后仅在需要时进行优化。

lems in turn.

 is slower than somebody's specialized My_container&lt;X&gt;

er.

align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

t><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

tical-align: inherit;"> 2.10和

vertical-align: inherit;"> 11.5、15.3和C.11。

e="vertical-align: inherit;">

= h1.name和h2.p == h1.p。</font><font style="vertical-align: inherit;">这导致灾难：退出f（）时，将调用h1和h2的析构函数，并将h1.p和h2.p指向的对象删除两次。

herit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">最简单的解决方案是通过将复制操作设为私有来防止复制：

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 string＆hh）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

style="vertical-align: inherit;">	Ref &lt;My_type&gt; r =新的My_type；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

对象</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">//分配给参考</font></font><font></font>

id incr1（int＆x）; </font><font style="vertical-align: inherit;">// 增量</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

我不知道有什么道理。</font><font style="vertical-align: inherit;">如果传递``不是对象''（例如空指针）是可以接受的，则使用指针是有意义的。</font><font style="vertical-align: inherit;">我的个人风格是在我要修改对象时使用指针，因为在某些情况下，这样可以更轻松地发现可能进行修改。 

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

还要注意，成员函数的调用本质上是对对象的按引用调用，因此，当我们要修改对象的值/状态时，我们经常使用成员函数。

</font></font></p><p>



ertical-align: inherit;"><font style="vertical-align: inherit;">

有类的C）。</font><font style="vertical-align: inherit;">另外，我选择“ this”来遵循Simula的用法，而不是（后来的）Smalltalk对“ self”的用法。

也是一个非常低级的数据结构，具有很大的滥用和错误可能性，并且在几乎所有情况下，都有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

-align: inherit;"><font style="vertical-align: inherit;">	无效f（int a []，int s）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">a的大小是s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

[i] = i;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

作，而且经常有人犯错。</font><font style="rtical-align: inherit;"><font style="vertical-align: inherit;">下载

同）。</font><font style="vertical-align: inherit;">例如：

vertical-align: inherit;">

align: inherit;">

n: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></p><p>

;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
t style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

 my_sqrt（-1）; </font><font style="vertical-align: inherit;">//发生错误时返回-1</font></font><font></font><font style="vertical-align: inher;">。

ements<font></font>

for C++) and don't use ten-year-old

andard C++.

rtical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">它可能很旧，您可能安装错误，或者您的计算机可能是古董。</font><font style="vertical-align: inherit;">我不能帮你解决这些问题。

<font style="vertical-align: inherit;">

因此编译该程序时，编译器将检查数百个头文件和数万行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

t;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

align: inherit;">

ertical-align: inherit;">

tical-align: inherit;">

align: inherit;">

al-align: inherit;">

生类的实现者（例如Circle和Triangle）共享受保护成员表示的实现方面。

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

ont></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

（const complex＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

herit;">

n: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f2：很好，我们继承了Base :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

it;">//错误：未覆it;"><font style="vertical-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

lign: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

herit;"><font style="vertical-align: inherit;">

m/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取，即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（有时缩写为RAII
，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

gn: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

换，但要依靠动态检查。</font><font style="vertical-align: inherit;">这将需要对v成员的每次访问进行运行时检查，并且h（）在遇到v的最后一个元素时必须抛出异常。

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="verticalign: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

为在某些情况下，这样可以更轻松地发现可能进行修改。 

值/状态时，我们经常使用成员函数。

">

style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

>	const int S = 10;</font></font><font></font>

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

"vertical-align: inherit;">另一个示例是：

++）;

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器不同，并且因为C留下了许多不确定的东西。</font><font style="vertical-align: inherit;">对于细节，包括术语“未定义”，“未指定”，“实现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

困难。

lign: inherit;">

t style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">
tyle="vertical-align: inherit;">它鼓励人们将C ++用作

a href="http://www.stroustrup.com/resource-model.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全类型和资源安全的语言，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

行代码。</font><font style="vertical-align: inherit;">原则上，这是可以避免的。</font><font style="vertical-align: inherit;">如果此问题出在您的库供应商的设计中，那么您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

information changes), and excess inclusion of header files into user code

(because the "information helpful to implementers" needs those headers).

t;">

lign: inherit;">

gn: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

font></font><font></font>

;">

ont style="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">} // AX源自A</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">} // BX源自B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户制作AX和BX</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">//此用户进行AY和BY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

n: inherit;">

;">使用好奇的“ = 0”语法将虚函数声明为“纯”。</font><font style="vertical-align: inherit;">例如：

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，Base是一个抽象类（因为它具有纯虚函数），因此不能直接创建Base类的对象：Base（明确地）意味着是基类。</font><font style="vertical-align: inherit;">例如：

/fole="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

</font></font></p><p>

tical-align: inherit;">

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

tical-align: inherit;">

用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-></font>

font></font>

/font>

itialize image from file<font></font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.10和

l-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.5、15.3和C.11。

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

rit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

t;My_type&gt; r：-新的My_type;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

</pre>

<p>

inherit;">

ont><font style="vertical-align: inherit;">例如f（X＆）无效；</font><font style="vertical-align: inherit;">或作废f（X *）;

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

ame="arrays"><font style="vertal-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
cal-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

ont></a>



灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

l-align: inherit;">来自析构函数？</font></font></a></h2>

便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

lign: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font styertical-align: inherit;">

</pre>

<p>

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

">

style="vertical-align: inherit;">

>

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

描述任何当前的C ++实现：

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

"vertical-align: inherit;">另一个示例是：

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器不同，并且因为C留下了许多不确定的东西。</font><font style="vertical-align: inherit;">对于细节，包括术语“未定义”，“未指定”，“实现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

个正确的答案，如果不能令人满意的话。</font><font style="vertical-align: inherit;">与C一样，C ++旨在直接有效地利用硬件。</font><font style="vertical-align: inherit;">这意味着C ++必须处理硬件实体，例
位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

困难。

lign: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

t style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-ali实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

的，单独的和未充分使用的工具。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

>

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-alle="vertical-align: inherit;">。

途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

></font>

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

t;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
tical-align: inherit;">

用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

herit;">

rit;">

rit;">

inherit;">

nherit;">

t></font><font></font>

 style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

gn: inherit;"><font style="vertical-align: inherit;">

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

style="vertical-align: inherit;">

font style="vertical-align: inherit;">

vertical-align: inherit;">我更喜欢使用标准库向量的更简单，更干净的版本：

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

做某事</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

<font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

ase）时，下标不再正确工作-在大多数情况下都是这种情况。</font><font style="vertical-align: inherit;">如果改用向量，则错误将在编译时捕获：

>	无效f（vector &lt;Base&gt;＆v）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">

，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

font style="vertical-align: inherit;">它具有关键布局示例图。</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二章有一个非常简短的解释

ign: inherit;">。

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	v [i] = i ++;

</font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

地利用硬件。</font><font style="vertical-align: inherit;">这意味着C ++必须处理硬件实体，例如位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行
机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

机器的内存和地址概念的直接表示，没有任何开销。</font><font style="vertical-align: inherit;">指针上的原始操作直接映射到机器指令上。</font><font style="vertical-align: inherit;">特别是，不进行范围检查。</font><font style="vertical-align: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
it;">等等。）。</font><font style="vertical-align: inherit;">一个好的编译器可以在编译时捕获a [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

lign: inherit;"><font style="vertical-align: inherit;">

译模型。</font><font style="vertical-align: inherit;">编译器无法在单独编译的翻译单元中检测到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	// file1.c：</font></font><font><
 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

align: inherit;">

东西-不在语言中？

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

ont><font style="vertical-align: inherit;">从那时起，出现了许多使这些约束类易于编写并仍然触发良好错误消息的想法。</font><font style="vertical-align: inherit;">例如，我相信使用指针来实现Can_copy中的功能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

-align: inherit;"><font style="vertical-align: inherit;">

，为什么要使用sort（）？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</fo误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// x！= sx !!</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

it;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

然，除非这些是属性）正在受约束测试）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 b）{a == b; </font><font style="vertical-align: inherit;">a！= b; </font><font style="vertical-align: inherit;">a &lt;b; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2，类别T3 = T1&gt; struct Can_multiply {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 b，T3 c）{c = a * b; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（T1，T2，T3）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="ype. The standard-library list

ed by a copy for each operation inserting an element

emoving an element). For std::list with the

nt. For small elements where the copy overhead is not

 allocator. Use a hand-crafted intrusive lists only

的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{删除p; </font><font style="vertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

值/状态时，我们经常使用成员函数。

">

cal-align: inherit;">

style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

++）;

在C ++中有些东西未定义？</font></font></a></h2>

 style="使用成员函数。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

"><font style="vertical-align: inherit;">

lign: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

="vertical-align: inherit;">

 inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">因此，不同的实现会做不同的事情。</font><font style="vertical-align: inherit;">不幸的是，我所知道的最好的解释是在一本书中，而这本书已经过时，并且没
描述任何当前的C ++实现：

yle="vertical-align: inherit;">};

"vertical-align: inherit;">};

++）;

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

ign: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

erit;">

herit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><f是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

erit;">。

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">//定义</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

t;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

n: inherit;">

>

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

基本上，仅当您希望对象的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

</font></font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	X * g（int i）{/ * ... * /返回新的X（i）; </font><font style="vertical-align: inherit;">} // X超过了g（）的调用</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效h（int i）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		X * p = g（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		删除p;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如果您希望对象仅存在于作用域中，请不要使用“ new”，而只需定义一个变量即可：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

                ClassName x;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

                //使用x</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

        }</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

该变量在作用域末尾隐式销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用new创建对象然后在同一作用域末尾将其删除的代码很丑陋，容易出错并且效率低下。</font><font style="vertical-align: inherit;">例如：

</font></font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void fct（）//难看，容易出错且效率低下</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		X * p =新的X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		//使用p</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		删除p;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

</pre>

<hr>

<h2><a name="void-main"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可以写“ void main（）”吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

定义

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void main（）{/ * ... * /}

</font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不是，也永远不是C ++，甚至不是C。请参见ISO C ++标准3.6.1 [2]或ISO C标准5.1.2.2.1。</font><font style="vertical-align: inherit;">符合标准的实现接受

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	int main（）{/ * ... * /}

</font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

和

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	int main（int argc，char * argv []）{/ * ... * /}

</font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

符合标准的实现可能会提供main（）的更多版本，但是它们都必须具有返回类型int。</font><font style="vertical-align: inherit;">main（）返回的int是程序将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

</font><准的实现可能会提供main（）的更多版本，但是它们都必须具有返回类型int。</font><font style="vertical-align: inherit;">main（）返回的int是程序将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">所以：

cal-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font stygn: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

it;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;int，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

-align: inherit;"><font style="vertical-align: inherit;">

，为什么要使用sort（）？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">	qsort（array，asize，sizeof（elem），elem_compare）;

l-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">	sort（vec.begin（），vec.end（））;

l-align: inherit;"><font style="vertical-align: inherit;">

和相同的比较标准，sort（）往往比qsort（）更快，这一事实通常很重要。</font><font style="vertical-align: inherit;">而且，sort（）是通用的，因此可以用于容器类型，元素类型和比较条件的任何合理组合。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	struct Record {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-ant><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	派生的类别：公共基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f1：很好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f2：很好，我们继承了Base :: f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ble d）{cout &lt;&lt;“ f（double）：”; </font><font style="vertical-align: inherit;">返回d + 1.3; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。

t;"><font style="vertical-align: inherit;">

f（）函数的重载集怎么办？</font><font style="vertical-align: inherit;">使用using声明很容易做到：

rit;"><font style="vertical-align: inherit;">	D级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

rit;">//使B中的每个f都可用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

”; </font><font style="vertical-align: inherit;">返回d + 1.3; </fo="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">	#include &lt;string&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

崩溃。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

e="vertical-align: inherit;">        类竞技场{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

plate &lt;class T&gt; void destroy（T * p，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;">yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

更容易理解。</font><font style="vertical-align: inherit;">也就是说，incr1（）更可能导致错误和错误。</font><font style="vertical-align: inherit;">因此，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

为在某些情况下，这样可以更轻松地发现可能进行修改。 

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

和空间而言，数组恰好是访问内存中对象序列的最佳构造。</font><font style="vertical-align: inherit;">但是，它也是一个非常低级的数据结构，具有很大的滥用和错误可能性，并且在几乎所有情况下，都有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

两个基本问题是

">

cal-align: inherit;">

ical-align: inherit;">

style="vertical-align: inherit;">

>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

lign: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

realloc（）在免费存储区中分配</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

好的解释是在一本书中，而这本书已经过时，并且没
描述任何当前的C ++实现：

的，单独的和未充分使用的工具。

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

="vertical-align: inherit;"><font style="vertical-align: inherit;">

恢复？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

供原始方法来返回引发异常的地方并从那里继续执行呢？

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nt><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

="vertical-align: inherit;">毕竟，我们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/except.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常安全性：概念和技术”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inheical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

和空间而言，数组恰好是访问内存中对象序列的最佳构造。</font><font style="vertical-align: inherit;">但是，它也是一个非常低级的数据结构，具有很大的滥用和错误可能性，并且在几乎所有情况下，都有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

两个基本问题是

/font></p><ul>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;
">

style="vertical-align: inherit;">

>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">另一个示例是：

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

>

ical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>



inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

为在某些情况下，这样可以更轻松地发现可能进行修改。 

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

描述任何当前的C ++实现：

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

"vertical-align: inherit;">另一个示例是：

的，单独的和未充分使用的工具。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全le="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
;"> 

允许x :: y重载，其中x是对象而不是名称空间或类，但是-与第一次出现相反，这涉及引入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

ont style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

: inherit;">

如：

对于正确使用C ++的更高级部分非常重要。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">。

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

gn: inherit;">请记住，保持一致的风格通常比以您认为最好的方式做每个小细节更重要vertical-align: inherit;"><font style="vertical-align: inherit;">

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

>

herit;">

需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

困难。

herit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-aign: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

l-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
tical-align: inherit;">

yle="vertical-align: inherit;">考虑在构造函数中检测到的错误；</font><font style="vertical-align: inherit;">您如何报告错误？</font><font style="vertical-align: inherit;">您抛出异常。</font><font style="vertical-align: in
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要纯虚拟Base :: f3</font></font><font></font>

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

t style="vertical-align: inherit;">

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

tical-align: inherit;">

e="vertical-align: inherit;">        类竞技场{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

指向Shapes的指针），并且在vi可以）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

测试），有关</font><font style="vertical-align: inherit;">

错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

rit;"> 

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



tical-align: inherit;">

;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">这与常见的不安全用法相反：

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

“ use f”部分抛出异常-或只是返回了-文件不会关闭。</font><font style="vertical-align: inherit;">在C程序中，longjmp（）是另外一个危险。

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

nherit;">	苹果类：公共水果{void apple_fct（）; </font><font style="vertical-align: inherit;">/ * ... * /};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

橙色没有apple_fct（）</font></font><font></font>

;">

gn: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

困难。

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

cal-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

ign: inherit;">毕竟，当我们编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

 struct Derived_from {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;DD，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;int，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;X，int&gt;（）;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Can_compare &lt;int，float&gt;（）;</font></font><font></font><fontl-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

">

;">

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

; </font><font style="vertical-align: inherit;">}</font></font><font></font>

: inherit;"><font style="vertical-align: inherit;">

erit;">

t;">

没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">
致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

yle="vertical-align: inherit;">

><font style="vertical-align: inherit;">

"vertical-align: inherit;">

果与要求“从左至右进行常规评估”之间的差异可能很大。</font><font style="vertical-align: inherit;">我不敢相信，但是随着无数的编译器“自由地”利用了自由，并且一些人热情地捍卫了这种自由，改变将是困难的，并且可能需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

指向从Shape公开派生的类的指针，或者是否是用户定义的转换为Shape *的类型的指针。</font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

ertical-align: inherit;">

ertical-align: inherit;"><font style="vertical-align: inherit;">

= a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;">



</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	qsort（array，asize，sizeof（elem），elem_compare）;

</font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

论文“将C ++作为一种新语言学习”，您可以从我的</font></font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

t style="vertical-align: inherit;">相比之下：当前的优化器很少（从来没有）能够通过指向函数的指针来内联调用。

inherit;"><font style="vertical-align: inherit;">

 inherit;">

 inherit;">

nt style="vertical-align: inherit;">但是，它们的应用令人惊讶地广泛，并且通过减少显式分配和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

机会。</font><font style="vertical-align: inherit;">这是一个示例，我需要从函数返回在免费存储区上分配的对象。</font><font style="vertical-align: inherit;">这是一个忘记删除该对象的机会。</font><font style="vertical-align: inherit;">毕竟，我们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

yle="ve

;">

-align: inherit;"><font style="vertical-align: inherit;">

T”和“ T const”分别是-和-都是允许的，并且是等效的。</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ign: inherit;">

源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

C ++的替代方法，例如内联函数，模板和名称空间。

ader.h”</font></font><font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

inherit;">//好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">// ouch：意味着（i ++ * i ++）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">// ouch：表示（d + 1 * d + 1）; </font><font style="vertical-align: inherit;">即（d + d + 1）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

*（x））/ *更好* /

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

辑的。



div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
rit;">的正确答案，</font><font style="vertical-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

gn: inherit;">

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

lign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

name_compare（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

是类型安全的，不需要强制转换即可使用它，并且他们不必为标准类型编写compare（）函数。

al-align: inherit;"><font style="vertical-align: inherit;">

论文“将C ++作为一种新语言学习”，您可以从我的</font></font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

erit;">。

al-align: inherit;"><font style="vertical-align: inherit;">

原因是比较内联更好。

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

;">

检测器，或插入垃圾收集器。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/except.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常安全性：概念和技术”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

测试），有关</font><font style="vertical-align: inherit;">

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。<align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

 no

 good hash function,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

rtical-align: inherit;">

的m（）; </font><font style="vertical-align: inherit;">//授予X :: m（）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作废f（X＆）; </font><font style="vertical-align: inherit;">//授予f（X＆）访问权限</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X＆）可以访问X :: i * /}</font></font><font></font>

t;">

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.10和

l-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.5、15.3和C.11。

>

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

inherit;">

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

style="vertical-align: inherit;">

>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

>	const int S = 10;</font></fon定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

困难。

t style="vertical-align: inherit;">

int，则我们会得到与for_each（）调用相关的某种模糊错误（因为我们无法为int调用Shape :: draw（））。 

herit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

然，除非这些是属性）正在受约束测试）

的特定错误（例如，“无法通过double *初始化Shape *” ”）

yle="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

仍然触发良好错误消息的想法。</font><font style="vertical-align: inherit;">例如，我相信使用指针来实现Can_copy中的功能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

编写模板时，我们具有C ++的全部表达能力。</font><font style="vertical-align: inherit;">考虑：

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

ont style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">



 style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

lign: inherit;">

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语
都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通rtical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

t;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">//此错误将被编译器捕获</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 g（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

互依赖关系，无论在哪里允许它都会导致严重的维护问题。

erit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
字等。

得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;"> 



</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：


产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

cal-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

nt style="vertical-align: inherit;"> 

strup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">附录着重于在要求苛刻的应用程序中编写异常安全代码的技术，而不是为新手编写的。

lign: inherit;"><font style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（有时缩写为RAII），该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

></font><font></font><font</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

ont></a>

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

2。

，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

rit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-/font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



tical-align: inherit;">

;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

gn: inherit;">

ign: inherit;">变得复杂

ical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

ont></a>

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="v">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（vector &lt;Record&gt;＆vs）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vs.begin（），vs.end（），name_compare（））;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大多数人都认为sort（）是类型安全的，不需要强制转换即可使用它，并且他们不必为标准类型编写compare（）函数。

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

ont></font>

t style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

l-align: inherit;">

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

检测器，或插入垃圾收集器。

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"<font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

上讲，所有容器（每种语言）都是同质的，因为要使用它们，必须为所有元素提供一个公共接口，以便用户依赖。</font><font style="vertical-align: inherit;">提供被认为是异构容器的语言只是提供了元素容器，这些元素都提供了标准接口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

类容器，因为它们在绝大多数情况下最容易使用，可提供最佳的编译时错误消息，并且不会造成不必要的运行时开销。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

font></font>

/font>

理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 no

 good hash function,

widely

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

al-align: inherit;"><font l-align: inherit;">来自析构函数？</font></font></a></h2>

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

ign: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><fo
nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

;">

nherit;">

ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style=align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

rtical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

类型。</font><font style="vertical-align: inherit;">您还必须考虑是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 



</p><hr>

<h2><a name="realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可以混合使容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

副本构造进行副本），那么vim.push_back（im）确实会很昂贵。</font><font style="vertical-align: inherit;">但是-俗话说-如果伤痛太大，那就不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 &lt;int&gt; vi;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">

vertical-align: inherit;">

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

C.11。

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">//使用默认值（0,0）创建orig</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">//使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">//调用Point（2,0）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

cal-align: inherit;"><font style="vertical-align: inherit;">

来获得用lign: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

align: inherit;">

rit;"><font style="vertical-align: inherit;">通过编写没有任何代码的代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

erit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
。

后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
-align: inherit;"> 

，否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

rtical-align: inherit;">

erit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

nt style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

lign: inherit;">

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

gn: inherit;">

>

heri>if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/except.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常安全性：概念和技术”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

 my_sqrt（-1）; </font><font style="vertical-align: inherit;">//发生错误时返回-1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

t>

cal-align: inherit;">my_negate（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都是某个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

es</font></b><font style="vertical-align: inherit;"> -complement表示形式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

www.stroustrup.com/programming.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。
 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（s，“ r”）; </font><font style="vertical-align: inherit;">// File_handle的构造函数打开名为“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

t;">//打开名为“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

ont></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

的水果操作函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it *&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，并且h（）在遇到v的最后一个元素时必须抛出异常。

n: inherit;">

。

font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
的内存管理，也没有可能会溢出的固定大小的缓冲区。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

行（而不仅仅是一个单词），则可以执行以下操作：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

入一行：\ n”;</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

入了” &lt;&lt; s &lt;&lt;'\ n';</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

cal-align: inherit;"><font style="vertical-align: inherit;">

标准库功能的简要介绍，请参阅</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

ttp://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;"></font></a>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

该是什么？</font></font></a></接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

ut &lt;&lt; 1; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

困难。

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

）

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

erit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		Derived_from &lt;D，B&gt;（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

ont><font></font>

t style="vertical-align: inherit;">

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

">

;">

上下文。</font><font style="vertical-align: inherit;">为使代码正确无误，引发问题的作者和渔获物的作者需要彼此熟悉代码和上下文。</font><font style="vertical-align: inherit;">这造成了一个复杂的相互依赖关系，无论在哪里允许它都会导致严重的维护问题。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inh
ont></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： 并不是的。</font><font style="vertical-align: inherit;">现代C ++实现将使用异常的开销减少了百分之几（例如3％），这与没有错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

</font></font><a href="http://www.stroustrup.com/JSF-AV-rules.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSF ++中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

align: inherit;">：JSF ++适用于硬实时和对安全性要求很高的应用程序（飞行控制软件）。</font><font style="vertical-align: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

inherit;">

="vertical-align: inherit;">C ++编程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

tyle="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">附录着重于在要求苛刻的应用程序中编写异常安全代码的技术，而不是为新手编写的。

ont><font style="vertical-align: inherit;">例如：

{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

rit;">

lign: inherit;">

;">

 inherit;">/ * ... * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

font style="vertical-align: inherit;">资源获取，即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（有时缩写为RAII
，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inhe）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

>

即可使用它，并且他们不必为标准类型编写compare（）函数。

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

n: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

ont></font>

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

l-align: inherit;">

">

;">

上下文。</font><font style="vertical-align: inherit;">为使代码正确无误，引发问题的作者和渔获物的作者需要彼此熟悉代码和上下文。</font><font style="vertical-align: inherit;">这造成了一个复杂的相互依赖关系，无论在哪里允许它都会导致严重的维护问题。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

/font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-alignerit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
cal-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否则设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

-align: inherit;">

某个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">。

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

lign: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

cal-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

;">例如：

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

herit;"><font style="vertical-align: inherit;">

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

Apple的Orange。

t style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列ertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

">《 JSF飞机C ++编码标准》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

;">

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

留0。例如：

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><fo
nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></f: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是例外很昂贵！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： 并不是的。</font><font style="vertical-align: inherit;">现代C ++实现将使用异常的开销减少了百分之几（例如3％），这与没有错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

SF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

tical-align: inherit;">

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

n: inherit;">

="vertical-align: inherit;">

Apple的Orange。

al-align: inherit;">其他情况则使用多重继承来处理。

着内存和访问成本。</font><font style="vertical-align: inherit;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

ic_cast和其他运行时检查。

个常见问题解答，而不是学术论文。

nherit;">

下进行操作，就像通过使用orig和p1的便利。</font><font style="vertical-align: inherit;">然后，有些人对f（）的调用中2到Point（2,0）的转换感到惊讶。</font><font style="vertical-align: inherit;">带有单个参数的构造函数定义一个转换。</font><font style="vertical-align: inherit;">默认情况下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	结构点{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

x = 0，int yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">//使用默认值（0,0）创建orig</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">//使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的显式调用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">//错误（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

 style="vertical-align: inherit;">

 style="vertical-align: inherit;">

inherit;">

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

值/状态时，我们经常使用成员函数。

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

style="vertical-align: inherit;">

>

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

进行涂抹。</font><font style="vertical-align: inherit;">自然，程序员通常会选择合适的大小，但是这是额外的工作，而且经常有人犯错。</font><font style="vertical-align: inherit;">我更喜欢使用标准库向量的更简单，更干净的版本：

inherit;"><font style="vertical-align: inherit;">	无效f（vector &lt;int&gt;＆v）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

[i] = i;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font>

t;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-alignt;"><font style="vertical-align: inherit;">变得复杂

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
herit;">

"><font style="vertical-align: inherit;">

>	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

rtical-align: inherit;">

 inherit;">

ical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">



it;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

ont></a>

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>





</p><hr>

<h2><a name="ctor-exceptions"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可以从构造函数中抛出异常吗？</font><font style="vertical-align: inherit;">来自析构函数？</font></font></a></h2>

<ul>

<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是：每当无法正确初始化（构造）对象时，都应从构造函数中引发异常。</font><font style="vertical-align: inherit;">没有真正令人满意的替代方法，可以通过抛出异常退出构造函数。 

</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不是真的：您可以在析构函数中引发异常，但是该异常一定不能离开析构函数。</font><font style="vertical-align: inherit;">如果析构函数抛出异常，则可能会发生各种不良情况，因为会违反标准库的基本规则和语言本身。</font><font style="vertical-align: inherit;">不要这样

 style="vertical-align: inherit;">}</font></font><font></font>



></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: ih2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

象类的语法糖。</font><font style="vertical-align: inherit;">也就是说，使用泛型（无论是Java还是C＃泛型），您都需要根据精确定义的接口进行编程，并且通常要支付使用函数的虚拟函数调用和/或动态强制转换的费用​​。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

模板参数，特殊化以及对内置和用户定义类型的统一处理等功能的组合来支持通用编程，模板元编程等。</font><font style="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

tical-align: inherit;">。

ions"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

中抛出异常吗？</font><font style="vertical-align: inherit;">来自析构函数？</font></font></a></h2>

l-align: inherit;"><font style="vertical-align: inherit;">

初始化（构造）对象时，都应从构造函数中引发异常。</font><font style="vertical-align: inherit;">没有真正令人满意的替代方法，可以通过抛出异常
退出构造函数。 

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

参阅</font></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

资源。</font><font style="vertical-align: inherit;">例如：

"><font style="vertical-align: inherit;">

auto_ptr &lt;X&gt;&gt; v; </font><font style="vertical-align: inherit;">//错误

，因为析构函数将使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

</font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用auto_array来保存数组吗？</font><font style="vertical-align: inherit;">否。没有auto_array。</font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

; v（n）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中发生异常，</font><font style="vertical-align: inherit;">则将正确调用</font></font><b><font style="vertical-align: inherit;"><fot><font></font>

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

功能的类的每个对象添加指针（vptr）来实现的。</font><font style="vertical-align: inherit;">该指针指向适当的函数表（vtbl）。</font><font style="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

"vertical-align: inherit;">另一个示例是：

用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
>

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

困难。

herit;">

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begrit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

gn: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">其他情况则使用多重继承来处理。

着内存和访问成本。</font><font style="vertical-align: inherit;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

ic_cast和其他运行时检查。

个常见问题解答，而不是学术论文。

nherit;">

下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
nherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

;">

 inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

-align: inherit;"></font></a><font style="vertical-align: inheritont><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

ical-align: inherit;">例子：

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

tical-align: inherit;">

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

ical-align: inherit;"><font style="vertical-align: inherit;">

 *转换？</font></font></a></h2>

"><font style="vertical-align: inherit;">

herit;">

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

gn: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">	typedef std :: complex &lt;double&gt; cmplx;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

）; </font><font style="vertical-align: inherit;">/ *错误：大小错误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
tical-align: inherit;">

用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

gn: inherit;"><font style="vertical-align: inherit;">

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

erit;">。

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

/font><font style="vertical-align: inherit;">这些示例可能很少见，但它们确实暗示不可能保证``指向已删除对象的任何指针都是0''。绕过``规则''的更简单方法是有两个指向对象的指针：

style="vertical-align: inherit;">	T * p =新的T;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

ont></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: 常优于变通方法（例如，使用转发
></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

 &lt;&lt; s &lt;&lt;'\ n';</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

库功能的简要介绍，请参阅</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

w.stroustrup.com/papers.html"><font style="vertical-align: inherit;"></font></a>

l-align: inherit;">来自析构函数？</font></font></a></h2>

inherit;">

函数中引发异常。</font><font style="vertical-align: inherit;">没有真正令人满意的替代方法，可以通过抛出异常退出构造函数。 

e="vertical-align: inherit;">

一定不能离开析构函数。</font><font style="vertical-align: inherit;">如果析构函数抛出异常，则可能会发生各种不良情况，因为会违反标准库的基本规则和语言本身。</font><font style="vertical-align: inherit;">不要这样

le="vertical-align: inherit;">

.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><
font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>



资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></fes should have been?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#sort">

why use sort() when we have "good old qsort()"?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#function-object">

What is a function object?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#auto_ptr">

What is an auto_ptr and why isn't there an auto_array?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#containers">

Why doesn't C++ provide heterogenous containers?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#slow-containers">

Why are the standard containers so slow?</a>

</li></ul>



</li><li>

<a name="memory">Memory</a>:

<ul>

<li>

<a href="http://www.stroustrup.com/bs_faq2.html#memory-leaks">

How do I deal with memory leaks?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#renew">

Why doesn't C++ have an equivalent to realloc()?</a>

</li><li>

<a href="http://www.stroustrup.com/bs_faq2.html#malloc">

What is the difference between <b>new</b> and <b>malloc()</b>?</a>

</li><li>

时，我会遇到很多有关如何编写非常简单的程序的问题。</font><font style="vertical-align: inherit;">通常，要解决的问题是阅读一些数字，对它们进行处理，然后写出答案。</font><font style="vertical-align: inherit;">这是一个执行此操作的示例程序：

vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		cout &lt;&lt;“ read” &lt;&lt; v.size（）&lt;&lt;“ elements \ n”;</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

s.html">my publications list</a>.

 format.

ended by finding end-of-file

ected type/format).

ate" in your C++ textbook.

 to count elements.

> to be a <i>vector&lt;double&gt;::size_type</i>

ilers,

ector needs more memory for elements, it allocates more;

ector goes out of scope, it frees that memory.

ements<font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">//成功返回</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

erit;"><font style="vertical-align: inherit;">

it;">这是一个雄心勃勃的项目，旨在指导人们采用现代C ++的有效风格，并提供支持其规则的工具。</font><font style="vertical-align: inherit;">它鼓励人们将C ++用作

it;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

for C++) and don't use ten-year-old

</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

 not have to depend on. For example, many

be logically independent of the definition

Color in the definition of Shape will probably

t;">

lign: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用户无需更改派生类的实现。</font><font style="vertical-align: inherit;">我已经看到该技术将构建时间减少了几个数量级。

ertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

eof-empty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

大小不为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

ical-align: inherit;">。

ont></font>

="ver变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

align: inherit;">下载该文件。

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

lign: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

tyle="vertical-align: inherit;">

l-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aut="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

中并不流行。

 destroy（T *＆p）{删除p; </font><font style="vertical-align: inherit;">p = 0; </font><font style="vertical-align: inherit;">}

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

: inherit;">

;">

ern“ C”''的函数。</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inh有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

nherit;">	苹果类：公共水果{void apple_fct（）; </font><font style="vertical-align: inherit;">/ * ... * /};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;"
>

 inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

 style="vertical-align: inherit;">}</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherint style="vertical-align: inherit;">v</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><a href="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

p><p>

回值的替代方法（类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">这样做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
="vertical-align: inherit;">

ont></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指向统一存储。

font><font style="vertical-align: inherit;">它返回一个指向其类型的（可选）初始化对象的指针。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过返回0报告内存耗尽。 

it;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
，并且确实有很多需要，请考虑使用标准库向量。</font><font style="vertical-align: inherit;">例如

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	//从输入中读取单词到字符串向量中：</font></font><font></font>

inherit;"><font style="vertical-align: inherit;">

，合法的C，而不是C ++ * /</font></font><font></font>

，您需要进行显式转换。</font><font style="vertical-align: inherit;">例如，要获得上述程序style="vertical-align: inherit;">

作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

</pre>

<p>

cal-align: inherit;">// v变为3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">// v变成4</font></font><font></font>

it;"><font style="vertical-align: inherit;">

法，而不是（后来的）Smalltalk对“ self”的用法。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">

style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><p>

</p><hr>

。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

描述任何当前的C ++实现：

"vertical-align: inherit;">第二章有一个非常简短的解释

个示例是：

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器不同，并且因为C留下了许多不确定的东西。</font><font style="vertical-align: inherit;">对于细节，包括术语“未定义”，“未指定”，“实现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

，out2（））; </font><font style="vertical-align: inherit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

困难。

l-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">//仅接受Shape * s的容器</font></font><font></font>

t style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font st中</font></a><font style="vertical-align: inherit;">下载该文件。

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

l-align: inherit;">来自析构函数？</font></font></a></h2>

inherit;">

rit;">不要这样

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f使用文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

中，每个资源都需要一个“资源句柄”类。</font><font style="vertical-align: inherit;">但是，我们不必为每次获取资源都使用“ finally”子句。</font><font style="vertical-align: inherit;">在现实的系统中，资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

nt></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-alignnherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

to_ptr“复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

font style="vertical-align: inherit;">

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

"vertical-align: inherit;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

。

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inheritin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

align: inherit;">

ont><font></font>

t style="vertical-align: inherit;">

们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

">

;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返;"></font></p><p>

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

间std;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

;">

oint（0,0），10）; </font><font style="vertical-alignC风格和C ++风格分配和释放吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是的，因为您可以在同一程序中使用malloc（）和new。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不可以，因为您无法使用malloc（）分配对象，也无法使用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++运算符new和delete保证正确的构造和销毁；</font><font style="vertical-align: inherit;">需要调用构造函数或析构函数的位置。</font><font style="vertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如果您觉得需要realloc（），并且确实有很多需要，请考虑使用标准库向量。</font><font style="vertical-align: inherit;">例如

</font></font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	//从输入中读取单词到字符串向">例如

中：</font></font><font></font>

.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

rtical-align: inherit;">考虑：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

gn: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

e="vertical-align: inherit;">请参见

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

 inherit;">

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

，将指针隐式地增加到数组中）依赖于它。</font><font style="vertical-align: inherit;">考虑：

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></ft;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

 inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅仅是从函数返回值的替代方法（类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">这样做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
n: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

nherit;">

。

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 



</p><hr>

<h2><a name="realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可ont><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

 inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅仅是从函数返回值的替代方法（类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">这样做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

构造函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

nherit;">

font><font style="vertical-align: inherit;">不幸的是，您不能为数组指定它。</font><font style="vertical-align: inherit;">通常，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

;">malloc（）时，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都必须考虑将返回指针初始化和转换为适当的类型。</font><font style="vertical-align: inherit;">您还必须考虑是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"o_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 



</p><hr>

<h2><a name="realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可以混合使用C风格和C ++风格分配和释放吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是的，因为您可以在同一程序中使用malloc（）和new。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不可以，因为您无法使用malloc（）分配对象，也无法使用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

</font></font></p><p><font style="vertical-align: inherit;"><font style="ve: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

"vertical-align: inherit;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 



</p><hr>

<h2><a name="realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可以混合使用C风格和C ++风格分配和释放吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是的，因为您可以在同一程序中使用malloc（）和new。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不可以，因为您无法使用malloc（）分配对象，也无法使用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		双dd = h（i，d）; </font><font style="vertical-align: inherit;">//错误：意外的参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

: inherit;">

如：



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

inherit;">

nherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误？

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

从y的类派生的类，而（T）是垂头丧气的。</font><font style="vertical-align: inherit;">也许x和y是不相关的指针类型。</font><font style="vertical-align: inherit;">因为可以使用C样式转换（T）来表示许多逻辑上不同的操作，所以编译器只有抓住错误的机会。</font><font style="vertical-align: inherit;">出于同样的原因，程序员可能不完全知道强制转换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

 p2 = reinterpret_cast&lt;double*&gt;(&amp;a);	// ok: I really mean it<font></font>

way const<font></font>

t;">

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个
主要原因：人类和编译器会看到不同的事物。

="vertical-align: inherit;">

;">

e="vertical-align: inherit;">

l-align: inherit;">

vertical-align: inherit;">

ertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



om/bio.html">bio</a>

class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

配数组：

gn: inherit;"><font style="vertical-align: inherit;">	void f（int a []，int b []，int size）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

>	const int S = 10;</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">//错误：无法将vector &lt;Derived&gt;转换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

手编程错误与数组的（错误）用法有关。

"vertical-align: inherit;"><font style="vertical-align: inherit;">

？</font></font></a></h2>

om/bs_faq2.html#no-derivation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它有，但是没有您想象的有用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

因此仅存在美学差异。</font><font style="vertical-align: inherit;">我更喜欢避免使用宏，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

rtical-align: inherit;"><font style="vertical-align: inherit;">

将其命名为nullptr；</font><font style="vertical-align: inherit;">这就是C ++ 11中的名称。</font><font style="vertical-align: inherit;">然后，“ nullptr”将成为关键字。

描述任何当前的C ++实现：

yle="vertical-align: inherit;">};

="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

ont style="vertical-align: inherit;">不要那样做 </font><font style="vertical-align: inherit;">另一个示例是：

t style="vertical-align: inherit;">令我失望的是，几十年来，大多数编译器仍然没有发出警告，而是将工作交给了专门的，单独的和未充分使用的工具。

的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

困难。

lign: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

消息，包括单词“ constraints”（为读者提供线索），约束的名称以及导致失败的特定错误（例如，“无法通过double *初始化Shape *” ”）

al-align: inherit;"><font style="vertical-align: inherit;">

2 = T1&gt; struct Can_compare {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

赖于在更易于管理的类型中隐藏分配和释放。</font><font style="vertical-align: inherit;">标准容器就是很好的例子。</font><font style="vertical-align: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

 inherit;">

有泄漏？

和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

们不能仅通过查看指针就知道是否需要释放ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

初始化* p * /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">//如果内存耗尽，将抛出bad_alloc</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

rit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

t;"><font style="vertical-align: inherit;">

受（没有特殊的预防措施）。</font><font style="vertical-alig
n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">//错误：尝试通过非常量引用传递右值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">//错误：尝试通过非常量引用传递右值</font></font><font></font>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用析构函数？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

”，但请看一下经常伴随该问题的示例：

vertical-align: inherit;"><font style="vertical-align: inherit;">	无效f（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
入新的语法（ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

rit;">

p><p>

const = 0;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font>

al-align: inherit;">

tyle="vertical-align: inherit;">

t style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

少了几个数量级。

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是安全的，并且可能是最有用的。</font><font style="vertical-align: inherit;">它允许程序员使用空类来表示非常简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

ign: inherit;">看，</font></font><a href="http://www.stroustrup.com/bs_faq2.html#abstract-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我的编译要花这么长时间？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

al-align: inherit;">考虑类复杂：

cal-align: inherit;">	template &lt;class Scalar&gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">



le="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

的？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">例如，参见</font></font><a href="http://www.stroustrup.com/bs_faq2.html#data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

herit;"><font style="vertical-align: inherit;">

虚拟功能调用机制所需的空间-通常每个对象一个字。</font><font style="vertical-align: inherit;">这种开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

yle="vertical-align: inherit;">

的对象的技术：

rit;"><font style="vertical-align: inherit;">	struct F {//对象创建函数的接口</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

l-align: inherit;">

align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

//不是虚拟的</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;">//虚拟的，不是纯的</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

有用。</font><font style="vertical-align: inherit;">实际上，仅具有纯虚函数的类通常称为接口。

rtical-align: inherit;"><font style="vertical-align: inherit;">

：

<h2><a name="overloadderived"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为什么重载对派生类不起作用？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

这个问题（在许多变体中）通常由以下示例提><font style="vertical-align: inhe
 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

指向T的T *的影响可能是灾难性的。</font><font style="vertical-align: inherit;">因此，在C ++中，要从void *获取T *，您需要进行显式转换。</font><font style="vertical-align: inherit;">例如，要获得上述程序的不良影响，您必须编写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">		int * pp =（int *）q;

/font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用新的样式转换使未选中的类型转换操作更加可见：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

/font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

免强制转换。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

种不安全转换的最常见用途之一是将malloc（）的结果分配给合适的指针。</font><font style="vertical-align: inherit;">例如：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * p = malloc（sizeof（int））;

/font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

可以在常量表达式中使用的常量（例如，作为数组绑定），则有两种选择：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 c1 = 7;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font>

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">//定义</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

:: c6; </font><font style="vertical-align: inherit;">//错误：c6不是左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

:: c7; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inher;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

c（）。

ree（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

以具有更大的灵活性：

rit;"><font style="vertical-align: inherit;">	Z类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">//在定义中初始化</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">//在构造函数中初始化</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

font></font>

="vertical-align: inherit;">

况下，您可以采用其地址：

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

，将指针隐式地增加到数组中）依赖于它。</font><font style="vertical-align: inherit;">考虑：

align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

style="vertical-align: inherit;">

ertical-align: inherit;">

为答案很明显，并且我的朋友也同意-然后我们发现我: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

 inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

cal-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
使用free（）删除，也不能在new分配的数组上使用realloc（）。

ertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

ign: inherit;">

配给合适的指针。</font><font style="vertical-align: inherit;">例如：

cal-align: inherit;">	int * p = malloc（sizeof（int））;

-align: inherit;">

align: inherit;">	int * p =新的int；

-align: inherit;">

是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

erit;">。

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">//定义</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

中并不流行。

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	in以混合使用C风格和C ++风格分配和释放吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是的，因为您可以在同一程序中使用malloc（）和new。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不可以，因为您无法使用malloc（）分配对象，也无法使用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

可以在常量表达式中使用的常量（例如，作为数组绑定），则有两种选择：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 c1 = 7;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

以具有更大的灵活性：

rit;"><font style="vertical-align: inherit;">	Z类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">//在定义中初始化</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">//在构造函数中初始化</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

font></font>

="vertical-align: inherit;">

况下，您可以采用其地址：

"><font style="vertical-align: inherit;">	AE类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

herit;">

it;"><font style="vertical-align: inherit;">

 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

/font><font style="vertical-align: inherit;">这些示例可能很少见，但它们确实暗示不可能保证``指向已删除对象的任何指针都是0''。绕过``规则''的更简单方法是有两个指向对象的指针：

style="vertical-align: inherit;">	T * p =新的T;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></fo不良影响，您必须编写：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * p = malloc（sizeof（int））;

l-align: inherit;"><font style="vertical-align: inherit;">

格：* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 p =（cmplx *）malloc（sizeof（int））; </font><font style="vertical-align: inherit;">/ *错误：大小错误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 *忘记测试p == 0 * /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是非常严格的：

标准扩展。

类，并且通常将头文件包含在许多翻译单元中。</font><font style="vertical-align: inherit;">但是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

><font></font><font style="vertical-align: inherit;"><font style="vertic
al-align: inherit;">

>

;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

i（ii）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

nherit;">	AE类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

;">

><font></font>

;">

e="vertical-align: inherit;">

C ++不能保证。

任何指针都是0''。绕过``规则''的更简单方法是有两个指向对象的指针：

-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

新的X（i）; </font><font style="vertical-align: inherit;">} // X超过了g（）的调用</font></font><font></font>



ertical-align: inherit;">	int main（int argc，char * argv []）{/ * ... * /}

vertical-align: inherit;">

们都必须具有返回类型int。</font><font style="vertical-align: inherit;">main（）返回的int是程序将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

tical-align: inherit;">

style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

e="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

l-align: inherit;">

nherit;"><font style="vertical-align: inherit;">

lign: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
/font><font style="vertical-align: inherit;">// </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p指向a [4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

ont></font><i><fo回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
herit;">

"><font style="vertical-align: inherit;">

>	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

灵活性的较不理想的结果是错误的延迟检测和严重的错误消息。</font><font style="vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

 </font><font style="vertical-align: inherit;">。

</font></font></p><p>





</p><hr>

<h2><a name="ctor-exceptions"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我可以从构造函数中抛出异常吗？</font><font style="vertical-align: inherit;">来自析构函数？</font></font></a></h2>

<ul>

<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">	无效f（int n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

align: inherit;">

name_compare {//比较以“名称”为键的记录</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

perator（）（const Record＆a，const Record＆b）const</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rn a.name &lt;b.name; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（vector &lt;Record&gt;＆vs）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vs.begin（），vs.end（），name_compare（））;</font></font><fo"vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

>

即可使用它，并且他们不必为标准类型编写compare（）函数。

l-align: inherit;">

习”，您可以从我的</font></font><a href="http://www.stroustru
p.com/papers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

ont><font></font>

t style="vertical-align: inherit;">

ont></font>

t style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

有泄漏？

e="vertical-align: inherit;">通过使用功能对象和标准算法，我可以消除像迭代器那样的指针使用，但是对于这样一个很小的程序，这似乎有些过头了。

，它们的应用令人惊讶地广泛，并且通过减少显式分配和取消分配的数量，可以使其余示例更容易跟踪。</font><font style="vertical-align: inherit;">早在1981年，我指出，通过将我必须明确跟踪的对象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

应用程序中需要的对象的nt><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

基本上，仅当您希望对象的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

</font></font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	X * g（int i）{/ * ... * /返回新的X（i）; </font><font style="vertical-align: inherit;">} // X超过了g（）的调用</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

: inherit;">

，而只需定义一个变量即可：

t;"><font style="vertical-align: inherit;">

使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

 inherit;">

ont></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

的名称，::进行（编译时）范围解析，而不是表达式求值。</font><font style="vertical-align: inherit;">可以想象允许x :: y重载，其中x是对象而不是名称空间或类，但是-与第一次出现相反，这涉及引入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

。</font><font style="vertical-align: inherit;">但是，这样做可能会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假定您可以重载。</font></font></i><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-</font><a href="http://www.stroustrup.com/JSF-AV-rules.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSF ++中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

会彻底禁止异常！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：JSF ++适用于硬实时和对安全性要求很高的应用程序（飞行控制软件）。</font><font style="vertical-align: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

/font></li><li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

“ use f”部分抛出异常-或只是返回了-文件不会关闭。</font><font style="vertical-align: inherit;">在C程序中，longjmp（）是另外一个危险。

gn: inherit;">

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
cal-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

l-align: inherit;">来自析构函数？</font></font></a></h2>

inherit;">

rit;">不要这样

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inheinherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

/font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

nherit;"><font style="vertical-align: inherit;">delete []</font></font><ign: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示错误，</font><font style="vertical-align: inherit;">仅使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">

font><font style="vertical-align: inherit;">不幸的是，您不能为数组指定它。</font><font style="vertical-align: inherit;">通常，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分隐式处理分配/取消分配，则可以使用资源句柄来最大程度地减少泄漏的机会。</font><font style="vertical-align: inherit;">这是一个示例，我需要从函数返回在免费存储区上分配的对象。</font><font style="vertical-align: inherit;">这是一个忘记删除该对象的机会。</font><font style="vertical-align: inherit;">毕竟，我们不能仅通过查看指针就知道是否需要释放指针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;内存&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

上下文。</font><font style="vertical-align: inherit;">为使代码正确无误，引发问题的作者和渔获物的作者需要彼此熟悉代码和上下文。</font><font style="vertical-align: inherit;">这造成了一个复杂的相互依赖关系，无论在哪里允许它都会导致严重的维护问题。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></p><p>





</p><hr>

<h2><a name="exceptions-why"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为什么要使用例外？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使用异常对我有什么好处？</font><font style="vertical-align: inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
老鼠的测试巢”）。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

首先，有些事情没有例外就无法正确完成。</font><font style="vertical-align: inherit;">考虑在构造函数中检测到的错误；</font><font style="vertical-align: inherit;">您如何报告错误？</font><font style="vertical-align: inherit;">您抛出异常。</font><font style="vertical-align: in
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，inherit;">

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

="vertical-align: inherit;">有关更多详细信息，请参见

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

gn: inherit;">

ern“ C”''的函数。</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

说``int * p;''或``int * p;''

-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

: inherit;">实际上，*绑定到语法中的名称p。

n: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font><font style="vertical-align: inherit;">例如：

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

它在类型之前或之后使用，因为我可以这样做而不会产生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

源。

way const<font></font>

t;">

转换导致错误的可能性要小一些。</font><font style="vertical-align: inherit;">原则上，可以使用static_cast的结果而无需将其强制转换回其原始类型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型rtical-align: inherit;">

C ++运算符new和delete保证正确的构造和销毁；</font><font style="vertical-align: inherit;">需要调用构造函数或析构函数的位置。</font><font style="vertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如果您觉得需要realloc（），并且确实有很多需要，请考虑使用标准库向量。</font><font style="vertical-align: inherit;">例如

</font></font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	//从输入中读取单词到字符串向量中：</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	vector &lt;string&gt;单词；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	字符串s;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	while（cin &gt;&gt; s &amp;&amp; s！=“。”）words.push_back（s）;</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

向量将根据需要扩展。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

herit;">

rit;">

rit;">

inherit;">

nherit;">

t></font><font></font>

 style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">

不良影响，您必须编写：

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

衡的说明，</font><font style="vertical-align: inherit;">请参见

rit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

'的更简单方法是有两个指向对象的指针：

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

nherit;"><font style="vertical-align: inherit;">

f（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

基本上，仅当您希望对象的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

使“ void main（）”成t * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

基本上，仅当您希望对象的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

</font></font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	X * g（int i）{/ * ... * /返回新的X（i）; </font><font style="vertical-align: inherit;">} // X超过了g（）的调用</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效h（int i）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		X * p = g（i）;</font></font><font></font><font style="vertical-aligt style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;">

t;">

）::？：sizeof

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

;">

nt style="vertical-align: inherit;">

l-align: inherit;">

？</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">在标准化时，尚不清楚哪种方法最好。</font><font style="vertical-align: inherit;">有关更多详细信息，请参见

 inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

ont style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

><font></font><font style="vertical-align: inherit;"><font style="v算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

ut &lt;&lt; 1; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">





的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

困难。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	template &lt;class T1，class T2&gt; struct Can_copy {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

1 a，T2 b）{T2 c = a; </font><font style="vertical-align: inherit;">b = a；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

* p）（T1，T2）=约束；</font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

it;">

it;">

然，除非这些是属性）正在受约束测试）

在广泛的用途中最有效尚未达成共识。

erit;"><font style="vertical-align: inherit;">

t></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">





rit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

vertical-align: inherit;">

之下：当前的优化器很少（从来没有）能够通过指向函数的指针来内联调用。

 inherit;">

象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器，资源句柄等的使用比几年前要容易得多。</font><font style="vertical-align: inherit;">异常的使用使其接近于必要。

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

数组上工作，这些数组包含没有用户定义的副本构造函数的对象。</font><font style="vertical-align: inherit;">另外，请记住，与天真期望相反，realloc（）偶尔会复制其参数数组。 

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font st
yle="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有tical-align: inherit;"><font style="vertical-align: inherit;">

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

开销可能非常大，并且可能妨碍与其他语言（例如C和Fortran）的数据在布局上的兼容性。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

>

n: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

	无效用户（const F＆fac）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

t;">

herit;">实际上，仅具有纯虚函数的类通常称为接口。

ign: inherit;">

cal-align: inherit;">	Base :: f3（）{/ * ... * /}

-align: inherit;">

但是在某些派生类中仍必须重写Base :: f3（）。

ign: inherit;">



cal-align: inherit;">	D2类：公共基地{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

Base :: f3</font></font><font></font>

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

崩溃。

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

ont><font></font>

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

管理指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font>

/font>

itialize image from file<font></font>

的成本，与大多数图像操作运算符相比，这是微不足，文件，套接字等。

gn: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

lign: inherit;">

据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到縊使用realloc（）。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++运算符new和delete保证正确的构造和销毁；</font><font style="vertical-align: inherit;">需要调用构造函数或析构函数的位置。</font><font style="vertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

herit;">

gn: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">	typedef std :: complex &lt;double&gt; cmplx;</font></font><font></font>

t;"><font style="vertical-align: inherit;">

;">

tyle="vertical-align: inherit;">

;">

rtical-align: inherit;">

常量必须是通过常量表达式初始化的整数或枚举类型
静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

style="vertical-align: inherit;">

font style="vertical-align: inherit;">

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

herit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

;">

nt style="vertical-align: inherit;">

l-align: inherit;">

？</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

ont style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

: inherit;">

;">

gn: inherit;">

t;">因此，您不能使用错误的参数数量来调用声明为``extern“ C”''的函数。</font><font style="vertical-align: inherit;">例如：

+代码</font></font><允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

：

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

;">

nt style="vertical-align: inherit;">

为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		双dd = h（i，d）; </font><font style="vertical-align: inherit;">//错误：意外的参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以像这样使用C :: f（）：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

call_C_f（struct C * p，int i）;</font></font><font></font>

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cc（struct C * p，int i）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

如：

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

n: inherit;">

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例可以更好地替代自由存储分配的数组（例如，考虑异常安全性）。

;">malloc（）时，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都必须考虑将返回指针初始化和转换为适当的类型。</font><font style="vertical-align: inherit;">您还必须考虑是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

nt></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过返回0报告内存耗尽。 

font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

ont></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
herit;">释放</font><font style="vertical-align: inherit;">。

tical-align: inherit;">

中：</font></font><font></font>

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

ical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创lign: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

ign: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">//定义</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

:: c6; </font><font style="vertical-align: inherit;">//错误：c6不是 inherit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

{/ * ... * /}

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

ont style="vertical-align: inherit;">

gn: inherit;">

ern“ C”''的函数。</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，p的整数值必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

cal-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

inherit;">// X :: f或Y :: f还是错误？</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">在标准化时，尚不清楚哪种方法最好。</font><font style="vertical-align: inherit;">有关更多详细信息，请参见

-to-string"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换为字符串？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是使用字符串流：

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ring&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tream&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

ccc（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

d）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

. * /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，即使您不能（或不想）修改C ++标头，也可以使用这t;">

技术从C代码调用C ++库。

tical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

</font><font style="vertical-align: inherit;">像大多数人一样，我很难为自己的喜好构建一个坚实的逻辑论据。

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

ertical-align: inherit;">

rit;">将函数的左括号放在新行上有助于我一眼就将函数定义与类定义区分开。

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">我认为“匈牙利语”（在变量名中包含类型的缩写版本）是一种在无类型语言中很有用的技术，但完全不适用于支持通用编程和面向对象编程的语言-两者都强调选择基于参数类型的操作（语言或运行时支持已知）。</font><font style="vertical-align: inherit;">在这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font>么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
，锁，文件，套接字等。

tyle="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font>
</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

ont><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

例外的常见异议：

/font></p><ul>

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是例外很昂贵！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： 并不是的。</font><font style="vertical-align: inherit;">现代C ++实现将使用异常的开销减少了百分之几（例如3％），这与没有错误处理相比。</font><font style="vertical-align: inherit;">用错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</fo
nt><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

SF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

，该</font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;">初始化</font></a><font style="vertical-align: inherit;">使用带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

换，但要依靠动态检查。</font><font style="vertical-align: inherit;">这将需要对v成员的每次访问进行运行时检查，并且h（）在遇到v的最后一个元素时必须抛出异常。

t;"><font style="vertical-align: inherit;">

/h2>

;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

tical-aligont><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

>

cal-align: inherit;">

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">。

inherit;"><font style="vertical-align: inherit;">

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

gn: inherit;">请记住，保持一致的风格通常比以您认为最好的方式做每个小细节更重要。

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

ertical-align: inherit;">	int const c = 10;

vertical-align: inherit;">

tical-align: inherit;">

e="vertical-align: inherit;">	readonly int c = 10;

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a do style="vertical-align: inherit;">

来删除“拥有的”对象）。

</font></font><p>

The second frequently occuring genuine performance problem is the use of a map&lt;string,X&gt; for

的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

l-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font></font>

l-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.10和

函数和一个复制所有元素的复制分配。</font><font style="vertical-align: inherit;">例如：

inherit;"><font style="vertical-align: inherit;">	结构点{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{删除p; </font><font style="vertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

误（提示的隐式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

onst complex＆y）//带有引用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

it;"><font style="vertical-align: inherit;">

更容易理解。</font><font style="vertical-align: inherit;">也就是说，incr1（）更可能导致错误和错误。</font><font style="vertical-align: inherit;">因此，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

和空间而言，数组恰好是访问内存中对象序列的最佳构造。</font><font style="vertical-align: inherit;">但是，它也是一个非常低级的数据结构，具有很大的滥用和错误可能性，并且在几乎所有情况下，都有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

lign: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

&gt;＆b，整数大小）</font></font><fon那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

ont></a>

nt style="vertical-align: inherit;">

使用泛型（无论是Java还是C＃泛型），您都需要根据精确定义的接口进行编程，并且通常要支付使用函数的虚拟函数调用和/或动态强制转换的费用​​。

能的组合来支持通用编程，模板元编程等。</font><font style="vertical-align: inherit;">结果是灵活性，通用性和性能是“泛型”所无法比拟的。</font><font style="vertical-align: inherit;">STL是最好的例子。

vertical-align: inherit;">当前这是通过</font></font><a href="http://www.stroustrup.com/bs_faq2.html#constraints"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接解决的

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

">《 JSF飞机C ++编码标准》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。



rtical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

lign: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

">}</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f使用文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

中，每个资源都需要一个“资源句柄”类。</font><font style="vertical-align: inherit;">但是，我们不必为每次获取资源都使用“ finally”子句。</font><font style="vertical-align: inherit;">在现实的系统中，资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vert为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

，将指针隐式地增加到数组中）依赖于它。</font><font style="vertical-align: inherit;">考虑：

gn: inherit;"><font style="vertical-align: inherit;">	X a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">// </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p指向a [4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

n: inherit;"><font style="vertical-align: inherit;">因此，p的整数值必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

n: inherit;"><font style="vertical-align: inherit;">比q的整数值大sizeof（X）</font></font></i>

align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

style="vertical-align: inherit;">

ertical-align: inherit;">

为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

gn: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以像这样使用C :: f（）：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

: inherit;">



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t>

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

``int * p;''之间进行选择不是关于对与错，而是关于样式和强调。</font><font style="vertical-align: inherit;">C强调表达；</font><font style="vertical-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

'的更简单方法是有两个指向对象的指针：

>

nherit;"><font style="vertical-align: inherit;">

f（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

{/ * ... * /}

将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

="vertical-align: inherit;">例如：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

ont style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">通常，人们对代码布局的观点持坚决态度，但是一致性比任何特定样式都重要。</font><font style="vertical-align: inherit;">像大多数人一样，我很难为自己的喜好构建一个坚实的逻辑论据。

<font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">当为C中找不到的构造添加约定时，这有时称为“ Stroustrup”样式。</font><font style="vertical-align: inherit;">例如：

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

生歧义。</font><font style="vertical-align: inherit;">预标准C和Cn: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

继承吗？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">通过使用变通办法，我们可以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-align: inherit;">但是，每种具有静态类型检查和继承的现代语言都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
分配的对象），以便于编程，检测逻辑问题，

ign: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font>

cal-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">下载该文件。

ont></a>

rit;">不要这样

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

e="vertical-align: inherit;">C ++编程语言</font></a></font><a href="http://www.stroustrup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

会泄漏。</font><font style="vertical-align: inherit;">有关详细信息，请参见TC ++ PL 14.4.2。

指针。</font><font style="vertical-align: inherit;">如果将一个auto_ptr“不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

ont style="vertical-align: inherit;">

="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

如：



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t>

it;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

对于正确使用C ++的更高级部分非常重要。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

inherit;">//好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

），异常（用于退出上下文）等。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inhyle="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

tical-align: inherit;">

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

ical-align: inherit;"><font style="vertical-align: inherit;">

 *转换？</font></font></a></h2>

"><font style="vertical-align: inherit;">

转换为T *。</font><font style="vertical-align: inherit;">这是不安全的。</font><font style="vertical-align: inherit;">考虑：

ical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;stdio.h&gt;</font></font><font></font>

: inherit;"><font style="vertical-align: inherit;">

herit;">

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

gn: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">	typedef std :: complex &lt;double&gt; cmplx;</font></font><font></font>

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

可以在常量表达式中使用的常量（例如，作为数组绑定），则有两种选择：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

tyle="vertical-align: inherit;">

是，为避免复杂的链接器规则，C ++要求每个对象都有唯一的定义。</font><font style="vertical-align: inherit;">如果C ++允许在类中定义需要作为对象存储在内存中的实体，则该规则将被打破。</font><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">C ++设计权衡的说明，</font><font style="vertical-align: inherit;">请参见

erit;">。

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

nherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font st: inherit;"><font style="vertical-align: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那将是一团糟。

-align: inherit;"><font style="vertical-align: inherit;">        X * p1 = new（a1）X;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我们可以写：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        destroy（p1，a1）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p2，a2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

destroy（p3，a3）;</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL（SE）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.6 </font><font style="vertical-align: inherit;">定义匹配的运算符new（）和运算符delete（）对

lign: inherit;">另请参阅

仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

理由将对性能至关重要的功能虚拟化的原因仅在于“这就是我们通常这样做的方式”。

原因防止推导，在C ++ 11中有一个解决方案。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	struct Base {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

是final; </font><font style="vertical-align: inherit;">你不能从中得到</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

/h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不同类型的元素，则必须将其表示为联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

从Shape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如ical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

: inherit;"><font style="vertical-align: inherit;">catch</font></font></
b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">//分配默认的构造X</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

cal-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
tical-align: inherit;">

用Delete释放对象。</font><font style="vertical-align: inherit;">也不能使用new分配，也不能使用free（）删除，也不能在new分配的数组上使用realloc（）。

"vertical-align: inherit;">

tyle="vertical-align: inherit;">需要调用构造函数或析构凂，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

从y的类派生的类，而（T）是垂头丧气的。</font><font style="vertical-align: inherit;">也许x和y是不相关的指针类型。</font><font style="vertical-align: inherit;">因为可以使用C样式转换（T）来表示许多逻辑上不同的操作，所以编译器只有抓住错误的机会。</font><font style="vertical-align: inherit;">出于同样的原因，程序员可能不完全知道强制转换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

主要原因：人类和编译器会看到不同的事物。

="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

 style="vertical-align: inherit;">哥伦比亚大学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

style="vertical-align: inherit;">剑桥丘吉尔学院</font></font></a>

a>



</a>

om/bio.html">bio</a>

ng: 8px; float: left; width: 100%;"><h1 class="title gray">原文</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
font></font>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t>

it;"><font style="vertical-align: inherit;">

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

C ++标头，也可以使用这些技术从C代码调用C ++库。

说``int * p;''或``int * p;''

rtical-align: inherit;">。

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont>

cal-align: inherit;"><font style="vertical-align: inherit;">

布局样式更好地节省了垂直空间，我希望在屏幕上尽可能地合理地容纳。</font><font style="vertical-align: inherit;">将函数的左括号放在新行上有助于我一眼就将函数定义与类定义区分开。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

he use of

tical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

uld

 are obvious,

e.

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">//指向常量int的指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">//指向常量int的指针</font></font><font></font>

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

ader.h”</font></font><font></font>

it;">

译或（更糟糕的）编译成意外的东西。</font><ferit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

om/bio.html">bio</a>

-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

align: inherit;">有关更多详细信息，请参见

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

ont style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

gn: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font><font style="vertical-align: inherit;">例如：

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

那么即使看上去很无辜的演员也可能成为一个严重的问题。</font><font style="vertical-align: inherit;">例如，这是什么意思？：

表示值转换。</font><font style="vertical-align: inherit;">也许x是从y的类派生的类，而（T）是垂头丧气的。</font><font style="vertical-align: inherit;">也许x和y是不相关的指针类型。</font><font style="vertical-align: inherit;">因为可以使用C样式转换（T）来表示许多逻辑上不同的操作，所以编译器只有抓住错误的机会。</font><font style="vertical-align: inherit;">出于同样的原因，程序员可能不完全知道强制转换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器复制”到另一个中，则分配给auto_ptr的将保留指针，而分配的auto_ptr的将保留0。例如：

&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">



nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

行优化的）。

e="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

cal-align: inherit;">是一个以数字（字节）为参数的函数；</font><font style="vertical-align: inherit;">它返回一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指向统一存储。

vertical-align: inherit;">是一个运算符，它使用一个类型和（可选）该类型的一组初始化程序作为其参数；</font><font style="vertical-align: inherit;">它返回一个指向其类型的（可选）初始化对象的指针。</font><font style="vertical-align: inherit;">当您要分配具有非平凡的初始化语义的用户定义类型的对象时，差异最明显。</font><font style="vertical-align: inherit;">例子：

-align: inherit;"><font style="vertical-align: inherit;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

n: inherit;">通过返回0报告内存耗尽。 

ical-align: inherit;">报告通过引发异常来报告分配和初始化错误。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

tical-align: inherit;">

中：</font></font><font></font>

rtical-align: inhererit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

rtical-align: inherit;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

不良影响，您必须编写：

gn: inherit;"><font style="vertical-align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

;">

tyle="vertical-align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

rit;">

左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个uble)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

 p2 = reinterpret_cast&lt;double*&gt;(&amp;a);	// ok: I really mean it<font></font>

font>

nt c = 7;<font></font>

way const<font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

inherit;">//好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

see-out”。</font><font style="vertical-align: inherit;">“ c”代表“字符”，因为iostream将值与字节（字符）表示形式相互映射。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。



om/bio.html">bio</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

rit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

har * a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;">}</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

f使用文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

资源获取要比资源种类多得多，因此“使用资源获取是初始化”技术所产生的代码少于使用“最终”构造的代码。

ly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源获取即初始化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">来支持异常安全

其作用域末尾指向的对象。</font><font style="vertical-align: inherit;">例如：

tyle="vertical-align: inherit;">

l-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

用析构函数。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><fo
nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

"vertical-align: inherit;">

;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

nherit;">

。

是否获得了适合您使用的字节数。</fo数的位置。</font><font style="vertical-align: inherit;">C风格的函数malloc（），calloc（），free（）和realloc（）不能确保做到这一点。</font><font style="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

"vertical-align: inherit;">

中：</font></font><font></font>

herit;">

rit;">

rit;">

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

ign: inherit;">

配给合适的指针。</font><font style="vertical-align: inherit;">例如：

cal-align: inherit;">	int * p = malloc（sizeof（int））;

-align: inherit;">

align: inherit;">	int * p =新的int；

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

style="vertical-align: inherit;">

font style="vertical-align: inherit;">

ml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

t;"><font style="vertical-align: inherit;">

以具有更大的灵活性：

rit;"><font style="vertical-align: inherit;">	Z类{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">//在定义中初始化</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;">

1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font style="vertical-align: inherit;">//定义</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

:: c6; </font><font style="vertical-align: inherit;">//错误：c6不是左值</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

:: c7; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

作数为零？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	删除p;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font></font>

ont style="vertical-align: inherit;">	删除p + 1;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;">

/font><font style="vertical-align: inherit;">这些示例可能很少见，但它们确实暗示不可能保证``指向已删除对象的任何指针都是0''。绕过``规则''的更简单方法是有两个指向对象的指针：

style="vertical-align: inherit;">	T * p =新的T;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;"><font style=ertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

uld

 are obvious,

e.

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

gn: inherit;">请记住，保持一致的风格通常比以您认为最好的方式做每个小细节更重要。

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

从y的类派生的类，而（T）是垂头丧气的。</font><font style="vertical-align: inherit;">也许x和y是不相关的指针类型。</font><font style="vertical-align: inherit;">因为可以使用C样式转换（T）来表示许多逻辑上不同的操作，所以编译器只有抓住错误的机会。</font><font style="vertical-align: inherit;">出于同样的原因，程序员可能不完全知道强制转换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型。

="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

*（x））/ *更好* /

），异常（用于退出上下文）等。

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

a>

="logo"><img src="./Stroustrup_ C++ Style and Technique FAQ_files/translate_24dp.png" width="20" height="20" alt="Google 翻译"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">原文</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stro道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

 no

 good hash function,

eld for every element type. The standard-library list

ed by a copy for each operation inserting an element

emoving an element). For std::list with the

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

rtical-align: inherit;">

l-align: inherit;">

ertical-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;"> 我的int如何转换为复数？

ign: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">





使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++）或在同一类型上需要两组不同的操作。</font><font style="vertical-align: inherit;">例如，对于单一类型，您既需要分配给所引用对象的操作，也需要分配给引用/指针的操作。</font><font style="vertical-align: inherit;">可以使用单独的运算符来完成此操作（如Simula中一样）。</font><font style="vertical-align: inherit;">例如：

t;My_type&gt; r：-新的My_type;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font>

</pre>

<p>



，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

style="vertical-align: inherit;">

nherit;">我的个人风格是在我要修改对象时使用指针，因为在某些情况下，这样可以更轻松地发现可能进行修改。 

值/状态时，我们经常使用成员函数。

ame="arrays"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

么了？</font></font></a></h2>

style="vertical-align: inherit;">

的更简单，更干净的版本：

">

"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

则必须更改为数组</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">

换为vector &lt;Base&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font><p>

</p><hr>

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

描述任的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

ont></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">《 C ++编程语言》的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以像这样使用C :: f（）：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

call_C_f（struct C * p，int i）;</font></font><font></font>

: inherit;">

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">。

严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-al当前的C ++实现：

"vertical-align: inherit;">第二章有一个非常简短的解释

"vertical-align: inherit;">另一个示例是：

的，单独的和未充分使用的工具。

在C ++中有些东西未定义？</font></font></a></h2>

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

器不同，并且因为C留下了许多不确定的东西。</font><font style="vertical-align: inherit;">对于细节，包括术语“未定义”，“未指定”，“实现定义”和“格式正确”的定义；</font><font style="vertical-align: inherit;">请参阅ISO C ++标准。</font><font style="vertical-align: inherit;">请注意，这些术语的含义不同于它们对ISO C标准的定义和某些常用用法。</font><font style="vertical-align: inherit;">当人们没有意识到并非每个人都共享定义时，您会得到令人困惑的讨论。

/font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

个正确的答案，如果不能令人满意的话。</font><font style="vertical-align: inherit;">与C一样，C ++旨在直接有效地利用硬件。</font><font style="vertical-align: inherit;">这意味着C ++必须处理硬件实体，例
位，字节，字，地址，整数计算和浮点计算，就像它们在给定机器上的方式一样，而不是像我们希望的那样。</font><font style="vertical-align: inherit;">请注意，人们称为“未定义”的许多“事物”实际上是“实现定义的”，因此只要知道运行的机器，我们就可以编写完全指定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

cal-align: inherit;">	int a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

非我们在分配之前为pa提供了更好的价值）</font></font><font></font>

n: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
 [100]的范围错误，而要捕获p [100]的范围错误则要困难得多，并且通常不可能在编译时捕获每个范围错误。

到对象或函数的定义不一致。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-align: inherit;">// x！= sx !!</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">链接器可能会捕获S的不一致定义，但没有义务这样做（大多数情况不是这样）。</font><font style="vertical-align: inherit;">在许多情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

，out2（））; </font><font style="vertical-align: inhe"vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

！</font></font><font></font>

al-align: inherit;">

希望实现能够做到这一点，但是这种想法似乎在实现者中并不流行。

yle="vertical-align: inherit;">

函数：

ont style="vertical-align: inherit;">	template &lt;class T&gt;内联void destroy（T *＆p）{删除p; </font><font style="vertical-align: inherit;">p = 0; </font><font style="vertical-align: inherit;">}

align: inherit;">

柄等来最大程度地减少对new和delete的显式使用。

t style="vertical-align: inherit;">

具有防止为右值调用destroy（）的额外好处：

ont style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

<font style="vertical-align: inherit;">符合标准的实现接受

{/ * ... * /}

 argc，char * argv []）{/ * ... * /}

ont><font style="vertical-align: inherit;">main（）返回的int是程序将值返回到调用它的“系统”的一种方式。</font><font style="vertical-align: inherit;">在不提供这种便利的系统上，返回值将被忽略，但不会使“ void main（）”成为合法的C ++或合法的C。即使您的编译器接受“ void main（）”，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

t;">

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

al-align: inherit;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

ont style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

gn: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int ，也应避免这样做，否则将有风险被C和C ++程序员视为无知。

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

al-align: inherit;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

 inherit;"><font style="vertical-align: inherit;">

h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		双dd = h（i，d）; </font><font style="vertical-align: inherit;">//错误：意外的参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></f：

vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

tical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

al-align: inherit;"><font style="vertical-align: inherit;">）。

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	D级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

B :: f; </font><font style="vertical-align: inherit;">//使B中的每个f都可用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">// Java样式（假设Java可能会重载+）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

样的对象应该是局部变量。

rit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D :: f。</font><font style="vertical-align: inherit;">考虑如果规则不同而从B :: B（）调用D :: f（）会发生什么：因为尚未运行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

<font style="vertical-align: inherit;">

此虚拟函数的行为与构造函数相同：仅使用局部定义-不会调用覆盖函数，以避免触及对象的（现已销毁）派生类部分。

t;"><font style="vertical-align: inherit;">

html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.4.3。

cal-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font><font style="vertical-align: inherit;">那将是一团糟。

"vertical-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">//明确的析构函数调用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;"> 10.4和TC ++ PL（SE）19.4.5。

了安全起见：确保不将我的类用作基类（例如，确保我可以复制对象而不必担心切片） 

数时，可以轻松地优化虚拟函数类的开销。

"><font style="vertical-align: inherit;">

: inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

&lt;Shape *&gt; vs;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;string&gt; lst;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;double&gt; l2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;字符串，记录*&gt; tbl;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;Key，vector &lt;Record *&gt;&gt; t2;</font></font><font></font>

le="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font></font></a><font style="vertical-align: inherit;"it;">出版物列表中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载这些示例和讨论

 -1; </font><font style="vertical-align: inherit;">/ *从＆i开始覆盖内存* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

（“％d％d \ n”，i，j）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

rit;">

n: inherit;">由于从定义上删除零指针是无害的，因此一种简单的解决方案是“删除p;”。</font><font style="vertical-align: inherit;">做一个“ P = 0;” </font><font style="vertical-align: inherit;">完成所有其他要求后。</font><font style="vertical-align: inherit;">但是，C ++不能保证。

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，main（）不必包含显式的return语句。</font><font style="vertical-align: inherit;">在这种情况下，返回的值为0，表示成功执行。</font><font style="vertical-align: inherit;">例如：

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#include &lt;iostream&gt;</font></font><font></font>

i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

：

style="vertical-align: inherit;">

ertical-align: inherit;">

a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

nherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

str（）;</font></font><font></font>

="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.5.3

="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-ign: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-align: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

rtical-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

way const<font></font>

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不能假设其他程序员始终如一地避免您认为“非常愚蠢”的事情。</font><font style="vertical-align: inherit;">例如，最近有人告诉我，他们遇到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#define前缀get_ready（）; </font><font style="vertical-align: inherit;">int ret__</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

i）ret __ = i; </font><font style="vertical-align: inherit;">做点什么（）; </font><font style="vertical-align: inherit;">转到出口</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

exit：cleanup（）; </font><font style="vertical-align: inherit;">返回ret__</font></font><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inheritret__</font></font><font></font>

;">

e="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼写是合乎逻辑的。

ical-align: inherit;">摩根士丹利</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 



div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div 
class="status-message" sti，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">

t;">

如：



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

``int * p;''之间进行选择不是关于对与错，而是关于样式和强调。</font><font style="vertical-align: inherit;">C强调表达；</font><font style="vertical-align: inherit;">声明常常被认为仅仅是必要的邪恶。</font><font style="vertical-align: inherit;">另一方面，C ++非常注重类型。

对于正确使用C ++的更高级部分非常重要。

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

faces</a>,

关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我的猜测是使用第一个版本会使更少的程序员感到困惑（``更惯用''）。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为什么？</font><font style="vertical-align: inherit;">当我发明“ const”（最初命名为“ readonly”，并具有一个相应的“ writeonly”）时，我允许它在类型之前或之后使用，因为我可以这样做而不会产生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于rit;">//打印12或21</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

/font><font style="vertical-align: inherit;">请注意，该定义接近最小值：

能的方式源自Alex Stepanov和Jeremy Siek。</font><font style="vertical-align: inherit;">我认为Can_copy（）还没有准备好进行标准化-需要更多使用。</font><font style="vertical-align: inherit;">同样，C ++社区中使用了不同形式的约束。</font><font style="vertical-align: inherit;">究竟哪种形式的约束模板在广泛的用途中最有效尚未达成共识。

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

而是转换，但这通常是一个更好的约束。</font><font style="vertical-align: inherit;">为约束寻找好名字可能很难。

in（），vec.end（））;

nt></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

为函数对象可以具有在多个调用之间保持不变的状态（如静态局部变量），并且可以从对象外部进行初始化和检查（与静态局部变量不同）。</font><font style="vertical-align: inherit;">例如：

gn: inherit;"><font style="vertical-align: inherit;">	类别总和{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

总和为” &lt;&lt; for_each（v.begin（），v.end（），Sum（0））&lt;&lt;“ \ n”;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

n: inherit;">他们无需花费过多的精力就可以更好地管理元素的内存。</font><font style="vertical-align: inherit;">考虑在没有字符串和向量的情况下编写此代码：

象数量从数万个减少到几十个，我将使程序从正确的任务正确地减少到易于管理甚至简单的事情。

标准库auto_ptr），可以清楚地知道责任在哪里：

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

">

;">

检测器，或插入垃圾收集器。

="vertical-align: inherit;"><font style="vertical-align: inherit;">

上下文。</font><font style="vertical-align: inherit;">为使代码正确无误，引发问题的作者和渔获物的作者需要彼此熟悉代码和上下文。</font><font style="vertical-align: inherit;">这造成了一个复杂的相互依赖关系，无论在哪里允许它都会导致严重的维护问题。

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-aligalign: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

如：



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

：

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">。

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

生歧义。</font><font style="vertical-align: inherit;">预标准C和C ++对说明符施加的排序规则很少（如果有的话）。

从y的类派生的类，而（T）是垂头丧气的。</font><font style="vertical-align: inherit;">也许x和y是不相关的指针类型。</font><font style="vertical-align: inherit;">因为可以使用C样式转换（T）来表示许多逻辑上不同的操作，所以编译器只有抓住错误的机会。</font><font style="vertical-align: inherit;">出于同样的原因，程序员可能不完全知道强制转换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

way const<font></font>

会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

inherit;">//好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

yle="vertical-align: inherit;">

n: inherit;">这似乎是不合逻辑的，因为“字符”的发音是“ ka-rak-ter”，但是没有人指责英语发音（不是“发音” :-）并且拼n: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">（输出文件流）构造既可以设置可变进一个“坏”状态（不ifstream的默认情况下），使得每个后续操作将失败。</font><font style="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

，记住或忘记）。</font><font style="vertical-align: inherit;">对于由多个对象组成的类，这真的很混乱，特别是如果那些子对象相互依赖。</font><font style="vertical-align: inherit;">有关更多信息，请参见</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《 C ++编程语言》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

strup.com/3rd_safe0.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有多个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

测试），有关</font><font style="vertical-align: inherit;">

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复〸点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。



;">例如：

"vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

herit;"><font style="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

>

="vertical-align: inherit;">

Apple的Orange。

<font style="vertical-align: inherit;">

;">堆对象自然不支持复制语义。</font><font style="vertical-align: inherit;">堆对象不支持简单的作用域行为（这会使</font></font><a href="http://www.stroustrup.com/bs_faq2.html#finally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得复杂

都提供某种形式的多重继承。</font><font style="vertical-align: inherit;">在C ++中，抽象类通常用作接口，一个类可以具有许多接口。</font><font style="vertical-align: inherit;">其他语言-通常被认为是“非MI”-对于它们的等同于纯抽象类仅具有一个单独的名称：接口。</font><font style="vertical-align: inherit;">语言提供继承（单个和多个）的原因是，语言支持的继承通常优于变通方法（例如，使用转发
ign: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

style="vertical-align: inherit;">第3章</font><font style="vertical-align: inherit;">（在线提供）。</font><font style="vertical-align: inherit;">有关C和C ++ I / O的简单用法的详细比较，请参阅“将标准C ++作为一种新语言学习”，可以从我的</font><a href="http://www.stroustrup.com/papers.html"><font style="vertical-align: inherit;">出版物列表中</font></a><font style="vertical-align: inherit;">下载该文件。

ont></a>

l-align: inherit;">来自析构函数？</font></font></a></h2>

inherit;">

font style="vertical-align: inherit;">附录E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的

程语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

的替代方法：“资源获取是初始化”技术（TC ++ PL3第14.4节）。</font><font style="vertical-align: inherit;">基本思想是用本地对象表示资源，以便本地对象的析构函数将释放该资源。</font><font style="vertical-align: inherit;">这样，程序员就不会忘记释放资源。</font><font style="vertical-align: inherit;">例如：

-align: inherit;"><font style="vertical-align: inherit;">	类File_handle {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

andle f（fn，“ rw”）; </font><font style="vertical-align: inherit;">//打开fn进行读写</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

l-align: inherit;">

 inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">标准容器需要通常的复制语义。</font><font style="vertical-align: inherit;">例如：

/b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除指针，</font><font style="vertical-align: inherit;">并且将无法为最后n-1个X调用析构函数。

font><font style="vertical-align: inherit;">原因是不需要一个。</font><font style="vertical-align: inherit;">更好的解决方案是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

="http://www.stroustrup.com/C++11FAQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unique_ptr</font></font></a><fo
nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来指定错误处理动作。</font><font style="vertical-align: inherit;">异常还有其他用途-在其他语言中很流行-但是在C ++中不是惯用语言，并且故意不被C ++实现很好地支持（这些实现是基于将异常用于错误处理的假设进行优化的）。

做会很慢，并且会使大多数习惯于仅用于错误处理的异常的C ++程序员感到困惑。</font><font style="vertical-align: inherit;">同样，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></i><font style="vertical-alig
><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么</font><font style="vertical-align: inherit;">

"vertical-align: inherit;">

></font>

;">

oint（0,0），10）; </font><font style="vertical-align: inherit;">//分配一个构建的圆</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

参数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;">//错误没有默认构造函数</font></font><font></font>

。

是否获得了适合您使用的字节数。</font><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

中：</font></font><font></font>

herit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

gn: inherit;"><font style="vertical-align: inherit;">

误* /</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

vertical-align: inherit;"><font style="vertical-align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

rit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{/ * ... * /}

t;">

ont><font style="vertical-align: inherit;">也就是说，与C89和ARM C ++相比，声明中缺少类型的地方不假定使用“ int”。</font><font style="vertical-align: inherit;">所以：

ont></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr1？expr2：expr3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">将无法保证仅</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
herit;"><font style="vertical-align: inherit;">

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

会引起有关操作是否用于对象重载的问题。</font><font style="vertical-align: inherit;">或所指的对象。</font><font style="vertical-align: inherit;">例如：

al-align: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

ertical-align: inherit;">

;">

nt style="vertical-align: inherit;">

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

al-align: inherit;">即使我在1983年第一次考虑它时，我也知道如何实现它。</font><font style="vertical-align: inherit;">但是，我的经验是，当我们超越最琐碎的示例时，对于操作员使用的“明显”含义，人们似乎会有微妙的分歧。</font><font style="vertical-align: inherit;">一个经典的例子是a ** b ** c。</font><font style="vertical-align: inherit;">假设**表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

以像这样使用C :: f（）：

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

如：

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
在屏幕上，并且难以快速阅读。</font><font style="vertical-align: inherit;">这些可能没问题：

_partition

ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

way const<font></font>

t;">

 inherit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不能假设其他程序员始终如一地避免您认为“非常愚蠢”的事情。</font><font style="vertical-align: inherit;">例如，最近有人告诉我，他们遇到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#define前缀get_ready（）; </font><font style="vertical-align: inherit;">int ret__</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

i）ret __ = i; </font><font style="vertical-align: inherit;">做点什么（）; </font><font style="vertical-align: inherit;">转到出口</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

），异常（用于退出上下文）等。

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">



om/bio.html">bio</a>

div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>

66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>
分配给p1。

函数调用</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

C ++ PL（SE）19.4.5。

快，以至于与使用普通函数调用的替代解决方案相比，它们在现实中对使用虚拟函数设计的类的使用不会产生可测量的运行时开销。</font><font style="vertical-align: inherit;">注意，虚函数调用机制通常仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函
数类的开销。

Derived是final; </font><font style="vertical-align: inherit;">你不能从中得到</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

nherit;">

p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 ++中的异构容器，请为所有元素定义一个通用接口，并为这些元素创建一个容器。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">

 (a copy of) i into vi<font></font>

ut (a copy of) im into vim<font></font>

不要做。</font><font style="vertical-align: inherit;">而是，使用一个句柄容器或一个指针容器。</font><font style="vertical-align: inherit;">例如，如果Image具有引用语义，则上面的代码将仅产生复制构造函数调用的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

lign: inherit;">

始化图像</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

of performance is needed.

gn: inherit;"><font style="vertical-align: inherit;">

nherit;">再次：在优化之前先进行测量。

le="vertical-align: inherit;">

授予访问权限的明确机制。</font><font style="vertical-align: inherit;">您（在符合标准的程序中）不能在不修改类源的情况下授予自己访问类的权限。</font><font style="vertical-align: inherit;">例如：

15.3和C.11。

xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;">

n: inherit;">

>

;">

le="vertical-align: inherit;">

t;">

t><font style="vertical-align: inherit;">这导致灾难：退出f（）时，将调用h1和h2的析构函数，并将h1.p和h2.p指向的对象删除两次。

数定义一个转换。</font><font style="vertical-align: inherit;">默认情况下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

rit;">考虑：

ont style="vertical-align: inherit;">// 增量</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

结构，具有很大的滥用和错误可能性，并且在几乎所有情况下，都有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

ertical-align: inherit;">	无效f（int a []，int s）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void f（int a []，int b []，int size）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

cal-alhape派生的任何类型的元素。</font><font style="vertical-align: inherit;">也就是说，vi是均质的，因为它的所有元素都是Shapes（准确地说，是指向Shapes的指针），并且在vi可以容纳多种Shapes元素（例如圆形，三角形等）的意义上是异构的。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

可以使用（公共）对象接口发现元素的真实类型。

it;">	Io_obj {/ * ... * /}; </font><font style="vertical-align: inherit;">//参与对象I / O所需的接口</font></font><font></font>

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

概是“相比什么？” </font><font style="vertical-align: inherit;">是一个更有用的答案。</font><font style="vertical-align: inherit;">当人们抱怨标准库容器的性能时，我通常会发现以下三个真正的问题之一（或许多神话和红色鲱鱼之一）：

-align: inherit;">

ont style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

font></font>

/font>

的成本，与大多数图像操作运算符相比，这是微不足道的。</font><font style="vertical-align: inherit;">如果某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

自然，如果使用指针，则必须考虑资源管理，但是指针容器本身可以是有效且便宜的资源句柄（通常，您需要一个带有析构函数的容器来删除“拥有的”对象）。

</font></font><p>

The second frequently occuring genuine performance problem is the use of a map&lt;string,X&gt; for

a large number of (string,X) pairs.

Maps are fine for relatively small containers

 no

 good hash function,

widely

为此担心，并使用reserve（）优化增长。</font><font style="vertical-align: inherit;">在评估了我的代码并反复遇到在实际程序中找不到reserve（）的性能优势之后，我停止使用它，除非需要它以避免迭代器无效（在我的代码中这种情况很少）。</font><font style="vertical-align: inherit;">再次：在优化之前先进行测量。

>

串n）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

，p（0）{/ *获取名为“ name”的X并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

{删除p; </font><font style="vertical-align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

/font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

X，并让p指向它* /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;">/ *发布X，称为“名称” * /}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

/font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

使用默认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><针，如果需要，则由谁负责。</font><font style="vertical-align: inherit;">使用资源句柄（在这里是标准库auto_ptr），可以清楚地知道责任在哪里：

"vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

检测器，或插入垃圾收集器。

="vertical-align: inherit;"><font style="vertical-align: inherit;">

对这个问题进行了相当详细的讨论。</font><font style="vertical-align: inherit;">请参阅《</font></font><a href="http://www.stroustrup.com/dne.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++的设计和演变》中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的异常处理一章

问题时才进行检查然后抛出的函数。</font><font style="vertical-align: inherit;">一个new_handler就是一个例子。

，realloc（）偶尔会复制其参数数组。 

在C ++中，处理重新分配的更好方法是使用标准库容器（例如vector），并

 </font></font><a href="http://www.stroustrup.com/bs_faq2.html#realloc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使其自然增长</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

</font></font></p><p>

align: inherit;"><font style="vertical-align: inherit;">

inherit;">基本的答案是：使用异常进行错误处理可以使您的代码更简单，更整洁，并且不会遗漏错误。</font><font style="vertical-align: inherit;">但是“良好的旧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -statements”有什么问题？</font><font style="vertical-align: inherit;">基本的答案是：使用这些代码，您的错误处理和正常的代码紧密地交织在一起。</font><font style="vertical-align: inherit;">这样，您的代码会变得混乱，并且很难确保您已处理所有错误（请考虑“意大利面条式代码”或“
tical-align: inherit;">

yle="vertical-align: inherit;">考虑在构造函数中检测到的错误；</font><font style="vertical-align: inherit;">您如何报告错误？</font><font style="vertical-align: inherit;">您抛出异常。</font><font style="vertical-align: in
herit;">这就是

C ++设计技术的基础：构造函数的工作是为类建立不变式（创建在其中运行成员函数的环境）。 ），并且通常需要获取资源，例如内存，锁，文件，套接字等。

住，构造函数通常在变量中调用初始化/构造对象：

t><font style="vertical-align: inherit;">//需要分配内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">那</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想。</font><font style="vertical-align: inherit;">例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ofstream</font></font></b><font style="vertical-align: inherit;"
<font style="vertical-align: inherit;">我们可以返回错误代码或设置非本地变量（例如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errno</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">除非立即测试全局变量（否则可能会重新设置它），否
设置全局变量将无法很好地工作。</font><font style="vertical-align: inherit;">如果您可能有yle="vertical-align: inherit;">

，将指针隐式地增加到数组中）依赖于它。</font><font style="vertical-align: inherit;">考虑：

gn: inherit;"><font style="vertical-align: inherit;">	X a [10];</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

izeof（X）</font></font></i>

入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尚不清楚这种并发症会带来什么好处。 

：

herit;">已经多次考虑了这种可能性，但是每次我/我们决定可能出现的问题胜过可能带来的好处时。

<font style="vertical-align: inherit;">

表示乘幂。</font><font style="vertical-align: inherit;">现在a ** b ** c是指（a ** b）** c还是a **（b ** c）？</font><font style="vertical-align: inherit;">我以为答案很明显，并且我的朋友也同意-然后我们发现我们不同意哪种决议是显而易见的。</font><font style="vertical-align: inherit;">我的猜测是，此类问题将导致细微的错误。

"vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	// C ++代码</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	无效more_code（int i，double d）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

函数（包括虚拟函数），则需要提供一个简单的包装器。</font><font style="vertical-align: inherit;">例如：

</font></font><font></font>



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示构建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph）

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

="vertical-align: inherit;">

cal-align: inherit;">

ical-align: inherit;">。

才能创建真正的本地对象（即，分配在堆栈上而不是堆上的对象）并确保正确内联简单的操作。</font><font style="vertical-align: inherit;">真正的本地对象和内联是使复杂程序的性能接近内置复杂类型的语言所必需的。

data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

"vertical-align: inherit;">虚函数仅在要用作派生类对象的接口的类中有意义（通常在堆上分配，并通过指针或引用进行访问）。

yle="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">只要该类具有至少一个虚函数。</font><font style="vertical-align: inherit;">具有虚函数表示类旨在充当派生类的接口，并且当存在时，派生类的对象可能会通过指向基的指针而被破坏。</font><font style="vertical-align: inherit;">例如：

>

n: inherit;"><font style="vertical-align: inherit;">

拟的，则不会调用Derived的析构函数-可能产生不良影响，例如未释放Derived拥有的资源。

al-align: inherit;">特别是，“虚拟”使我们可以调用仅知道接口而不知道对象确切类型的函数。</font><font style="vertical-align: inherit;">要创建对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;">

; </font><font style="vertical-align: inherit;">//错误：未覆盖纯虚拟f3</font></font><font></font>

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

 inherit;">

3会覆盖Base :: f3</font></font><font></font>

gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;">

rtical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">	f（双精度）：3.3</font></font><font></font><font style="
vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

样使用“ new”吗？</font></font></a></h2>

-align: inherit;"><font style="vertical-align: inherit;">

地做，通常会有更好的选择。</font><font style="vertical-align: inherit;">考虑：

inherit;">

t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

函数</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;">

行构造函数D :: D（），所以D :: f（）会尝试将其参数分配给未初始化的字符串s。</font><font style="vertical-align: inherit;">结果很可能是立即崩溃。

</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

已经提出，该规则是实现工件。</font><font style="vertical-align: inherit;">不是这样。</font><font style="vertical-align: inherit;">实际上，实现从构造函数调用虚拟函数和从其他函数调用虚拟函数的不安全规则将变得明显容易得多。</font><font style="vertical-align: inherit;">但是，这意味着不能编写任何虚拟函数来依赖基类建立的不变式。</font>
<font style="vertical-align: inherit;">那t;"><font style="vertical-align: inherit;"> 如何停止隐式转换？

n: inherit;">



</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	结构点{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		整数x，y;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

值（0,0）创建orig</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

认的y坐标0创建p1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

>

/font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	Ref &lt;My_type&gt; r =新的My_type；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;">//分配给对象</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

My_type；</font><font style="vertical-align: inherit;">//分配给参考</font></font><font></font>

const X＆）;

回样式将返回一种新值。

些情况下，这样可以更轻松地发现可能进行修改。 

用之前，“ this”已引入C ++（实际上是带有类的C）。</font><font style="vertical-align: inherit;">另外，我选择“ this”来遵循Simula的用法，而不是（后来的）Smalltalk对“ self”的用法。

>

有更好的选择。</font><font style="vertical-align: inherit;">“更好”是指易于编写，易于阅读，不易出错且速度一样快。

 inherit;">

通常会选择合适的大小，但是这是额外的工作，而且经常有人犯错。</font><font style="vertical-align: inherit;">我更喜欢使用标准库向量的更简单，更干净的版本：

v）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">//错误</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	}</font></font><font></font>

;"><font style="vertical-align: inherit;">

it;">如果改用向量，则错误将在编译时捕获：

-align: inherit;"><font style="vertical-align: inherit;">	无效f（vector &lt;Base&gt;＆v）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;">

ame="final"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

C ++没有final关键字？</font></font></a></h2>

e="vertical-align: inherit;">我更喜欢避免使用宏，所以我使用0。NULL的另一个问题是，人们有时会错误地认为它不同于0和/或不是整数。</font><font style="vertical-align: inherit;">在标准前代码中，有时将NULL定义为不合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

ign: inherit;">

 inherit;"><font style="vertical-align: inherit;">

e="vertical-align: inherit;">也就是说，三个int彼此相</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

vertical-align: inherit;">

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">

为派生类提供一些简单的通用实现细节），但是在某些派生类中仍必须重写Base :: f3（）。

tyle="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">

"vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">

align: inherit;">

f（double）”并对其进行调用。</font><font style="vertical-align: inherit;">它永远不会打扰B的（封闭）作用域。在C ++中，没有作用域之间的重载-派生类作用域也不是该一般规则的例外。</font><font style="vertical-align: inherit;">（有关</font><font style="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

l-align: inherit;">

最合适的f（）进行调用。

it;"><font style="vertical-align: inherit;">

比，z3的“ new”笨拙的使用是不必要且缓慢的。</font><font style="vertical-align: inherit;">如果您还“删除”了同一范围内的对象，则无需使用“新建”来创建对象。</font><font style="vertical-align: inherit;">这样的对象应该是局部变量。

font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;"> 13.2.4.2或</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL3</font></font></a><font style="vertical-align: inherit;"><font style="verti
cal-align: inherit;"> 15.4.3。

一团糟。

align: inherit;">

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

算符new（size_t sz，Arena＆a）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

展示位置的原因是，没有确保其正确使用的通用方法。</font><font style="vertical-align: inherit;">C ++类型系统中的任何内容都不允许我们推论p1指向在Arena a1中分配的对象。</font><font style="vertical-align: inherit;">可以将指向任何在任何位置分配的X的指针分配给p1。

要这么做？</font><font style="vertical-align: inherit;">有两个常见答案：

使用不会产生可测量的运行时开销。</font><font style="vertical-align: inherit;">注意，虚函数调用机制通常仅在通过指针或引用进行调用时使用。</font><font style="vertical-align: inherit;">直接为命名对象调用函数时，可以轻松地优化虚拟函数类的开销。

tical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">	类可用；</font></font><font></font>

"vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

font>

al-align: inherit;"><font style="vertical-align: inherit;">

	map &lt;Key，vector &lt;Record *&gt;&gt; t2;</font></font><font></font>

</pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

联合或（通常更好）表示为多态类型的指针的容器。</font><font style="vertical-align: inherit;">经典示例是：

e="vertical-align: inherit;">	vector &lt;Shape *&gt; vi; </font><font style="vertical-align: inherit;">//形状的指针向量

vertical-align: inherit;">

口。</font><font style="vertical-align: inherit;">例如，Java集合提供对象的容器（对对象的引用），并且您可以使用（公共）对象接口发现元素的真实类型。

个好兆头是您的代码中有大量的强制转换。

lign: inherit;"><font style="vertical-align: inherit;">

例如Boost :: Any）替代方法：

ical-align: inherit;"><font style="vertical-align: inherit;">	vector &lt;Any&gt; v;

into the container.

 huge objects:

style="vertical->

font>

n: inherit;"><font style="vertical-align: inherit;">

></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

p-&gt; f（i）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

t;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t>

it;"><font style="vertical-align: inherit;">

说``int * p;''或``int * p;''

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

rtical-align: inherit;">。

inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">通常，人们对代码布局的观点持坚决态度，但是一致性比任何特定样式都重要。</font><font style="vertical-align: inherit;">像大多数人一样，我很难为自己的喜好构建一个坚实的逻辑论据。

<font style="vertical-align: inherit;">

t><font style="vertical-align: inherit;">当为C中找不到的构造添加约定时，这有时称为“ Stroustrup”样式。</font><font style="vertical-align: inherit;">例如：

rit;"><font style="vertical-align: inherit;">C级：公共B {</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

erit;">

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜个线程访问全局变量，甚至不用考虑该技术。</font><font style="vertical-align: inherit;">返回值的问题在于选择错误的返回值可能需要技巧，而这是不可能的：

e="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确答案，</font><font style="vertical-align: inherit;">

式中的最大负数也没有正确的答案。</font><font style="vertical-align: inherit;">在这种情况下，我们将需要返回值对（并且通常需要记住进行测试），有关</font><font style="vertical-align: inherit;">

t;"><font style="vertical-align: inherit;">Beginning》编程手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

例外的常见异议：

/font></p><ul>

错误返回码和测试编写代码也不是免费的。</font><font style="vertical-align: inherit;">根据经验，不抛出异常时，异常处理非常便宜。</font><font style="vertical-align: inherit;">在某些实现上它不花任何钱。</font><font style="vertical-align: inherit;">引发异常会产生所有费用：也就是说，“普通代码”比使用错误返回代码和测试的代码要快。</font><font style="vertical-align: inherit;">仅当出现错误时，您才需要承担费用。

ign: inherit;">如果计算时间过长，则可能会导致死亡。</font><font style="vertical-align: inherit;">因此，我们必须</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应时间，而在当前的工具支持水平下，我们不能为例外情况做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，甚至免费商店的分配也被禁止！</font><font style="vertical-align: inherit;">实际上，JSF ++有关错误处理的建议会在我们拥有正确执行工具（即使用异常）的日子来模拟异常的使用。

: inherit;"><font style="vertical-align: inherit;">调用的构造函数中抛出异常</font><font style="vertical-align: inherit;">会导致内存泄漏！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">废话！</font><font style="vertical-align: inherit;">那是一个老妇的故事，是由一个编译器中的一个错误引起的-该错误在10年前立即被修复。

应用程序中编写异常安全代码的技术，而不是为新手编写的。

;">例如：

nt style="vertical-align: inherit;">

种简单方法。</font><font style="vertical-align: inherit;">由于语言定义鼓励他们，大多数用户都认为异常处理代码是错误处理代码，并且对实现进行了优化以反映该假设。

带有析构函数的类对资源管理施加顺序。</font><font style="vertical-align: inherit;">例如：

“ s”的文件</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

<font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

</a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

例如：

>

tical-align: inherit;">）。</font><font style="vertical-align: inherit;">通用基类鼓励使用dynamic_cast和其他运行时检查。

<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">我简化了论点。</font><font style="vertical-align: inherit;">这是一个常见问题解答，而不是学术论文。

"><font style="vertical-align: inherit;">

以在没有多重继承的情况下进行操作，就像通过使用变通办法在没有单一继承的情况下可以做到的那样。</font><font style="vertical-align: inherit;">通过使用变通办法，我们甚至可以不使用类。</font><font style="vertical-align: inherit;">C证明了这一观点。</font><font style="vertical-alignt><font style="vertical-align: inherit;">考虑初始化时</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><f
ont style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间没有性能差异</font><font style="vertical-align: inherit;">。

由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的对象</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的</font><b><font style="vertical-align: inherit;">内存</font></b><font style="vertical-align: inherit;">区域</font><font style="vertical-align: inherit;">由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inhe
rit;">free（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font><font style="vertical-align: inherit;">。

</font></font></p><p> 

e="vertical-align: inherit;">此外，不能保证new和delete用于获取和释放原始内存的机制与malloc（）和free（）兼容。</font><font style="vertical-align: inherit;">如果混合样式适用于您的系统，那么到目前为止，您只是“幸运”。

 inherit;">

不良影响，您必须编写：



align: inherit;">		int * pp = static_cast &lt;int *&gt;（q）;

-align: inherit;">

gn: inherit;"><font style="vertical-align: inherit;">

class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

常量？</font></font></a></h2>

;">

tyle="vertical-align: inherit;">

静态const。</font><font style="vertical-align: inherit;">这是非常严格的：

herit;"><font style="vertical-align: inherit;">

nt style="vertical-align: inherit;">

style="vertical-align: inherit;">

font style="vertical-align: inherit;">

rit;">

传递（以允许指针归零）具有防止为右值调用destroy（）的额外好处：

le="vertical-align: inherit;"><font style="vertical-align: inherit;">	int * f（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

也就是说，有一个（错误的）假设，即“ new”创建的对象将在函数末尾销毁。

</font></font><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

基本上，仅当您希望对象的生存期超出创建它的作用域的寿命时，才应使用“新”。完成后，您需要使用“删除”来销毁它。</font><font style="vertical-align: inherit;">例如：

n: inherit;"><font style="vertical-align: inherit;">

"><font style="vertical-align: inherit;">

{/ * ... * /}

: inherit;">所以：

ign: inherit;"><font style="vertical-align: inherit;">expr2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr3中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><f
入新的语法（以允许</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expr :: expr</font></font></i><font style="vertical-align: i您将无能为力（除非更改为更好的库/供应商），但是您可以构建自己的代码以最大程度地减少更改后的重新编译。</font><font style="vertical-align: inherit;">这样做的设计通常更好，更易于维护，因为它们表现出更好的关注点分离。

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

l-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;"><font style="vertical-align: inherit;">

lign: inherit;">

>

 inherit;">

;"><font style="vertical-align: inherit;">

 inherit;">

"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;">

herit;">

对象的地址不同。</font><font style="vertical-align: inherit;">由于相同的原因，“ new”总是返回指向不同对象的指针。</font><font style="vertical-align: inherit;">考虑：

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	类Empty {};</font></font><font></font>

-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;">

font><font style="vertical-align: inherit;">它允许程序员使用空类来表示非常简单的概念，而不会增加开销。</font><font style="vertical-align: inherit;">当前一些编译器提供了这种“空基类优化”。

 inherit;"><font style="vertical-align: inherit;">

gt;类复合体{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font style="vertical-align: inherit;">im + = a.im; </font><font style="vertical-align: inherit;">返回* this; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">

al-align: inherit;"><font style="vertical-align: inherit;">

，参见</font></font><a href="http://www.stroustrup.com/bs_faq2.html#data-in-class"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。

ont style="vertical-align: inherit;">	班级基础{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

inherit;"><font style="vertical-align: inherit;">

对象，您需要完整的信息。</font><font style="vertical-align: inherit;">特别是，您需要知道要创建的确切类型。</font><font style="vertical-align: inherit;">因此，“对构造函数的调用”不能是虚拟的。

		B * q = fac.make_a_B（）; </font><font style="vertical-align: inherit;">//制作适当类型的B</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		// ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">例如：

 inherit;"><font style="vertical-align: inherit;">

/font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

><font></font>

nt style="vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

nherit;">	f（双精度）：3.3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

le="vertical-align: inherit;">详细信息，</font><font style="vertical-align: inherit;">请参见

erit;">或

 inherit;">）。

（假设Java可能会重载+）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;">

herit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

 </font><font style="vertical-align: inherit;">f（ss）; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

;}><font style="vertical-align: inherit;"> 

ign: inherit;">

某个类，比如说Image，确实有很好的理由具有复制语义，那么通常使用指针容器是一个合理的解决方案：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

align: inherit;"><font style="vertical-align: inherit;">

ter than most people's homebrew.



 style="vertical-align: inherit;"><font style="vertical-align: inherit;">

rit;"><font style="vertical-align: inherit;">

编译器复制我的对象？

何关闭复印？

		整数x，y;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

		点（int xx = 0，int yy = 0）：x（xx），y（yy）{}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	};</font></font><font></font>

<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	点p1（1,2）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ertical-align: inherit;">通常，这正是您想要的（对于C兼容性至关重要），但请考虑以下事项：

ertical-align: inherit;">	类句柄{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

erit;"><font style="vertical-align: inherit;">

n: inherit;">

;">

le="vertical-align: inherit;">

n: inherit;">

nt style="vertical-align: inherit;">

的便利。</font><font style="vertical-align: inherit;">然后，有些人对f（）的调用中2到Point（2,0）的转换感到惊讶。</font><font style="vertical-align: inherit;">带有单个参数的构造函数定义一个转换。</font><font style="vertical-align: inherit;">默认情况下，这是一个隐式转换。</font><font style="vertical-align: inherit;">要要求这种转换是显式的，请声明构造函数为显式的：

）; </font><font style="vertical-align: inherit;">//好的（显式转换）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

<font></font>

inherit;">

递的对象并且对象很大，请通过const引用进行调用；</font><font style="vertical-align: inherit;">例如void f（const X＆）;

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

否则，按值调用。</font><font style="vertical-align: inherit;">例如空f（X）;



-align: inherit;"><font style="vertical-align: inherit;">我所说的“大”是什么意思？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

的东西。

-align: inherit;"><font style="vertical-align: inherit;">我为什么要更改参数？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

须这样做，但通常我们还有一种选择：产生新的价值。</font><font style="vertical-align: inherit;">考虑：

font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	void incr1（int＆x）; </font><font style="vertical-align: inherit;">// 增量</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

nt><font style="vertical-align: inherit;">因此，与创建新值的样式相比，只要创建和复制新值并不昂贵，返回样式将返回一种新值。

yle="vertical-align: inherit;"><font style="vertical-align: inherit;">

第二个调用将对不属于arr2的所有内存进行涂抹。</font><font style="vertical-align: inherit;">自然，程序员通常会选择合适的大小，但是这是额外的工作，而且经常有人犯错。</font><font style="vertical-align: inherit;">我更喜欢使用标准库向量的更简单，更干净的版本：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	无效f（vector &lt;int&gt;＆v）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

it;"><font style="t></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

realloc（）在免费存储区中分配</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font>

cal-align: inherit;"><font style="vertical-align: inherit;">

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int S = 10;</font></font><font></font>

="vertical-align: inherit;">

 inherit;">

"vertical-align: inherit;">

it;"><font style="vertical-align: inherit;">

<h2><a name="null"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

我应该使用NULL还是0？</font></font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t;">这些天来这种情况不太常见。

yle="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

。</font><font style="vertical-align: inherit;">因此，不同的实现会做不同的事情。</font><font style="vertical-align: inherit;">不幸的是，我所知道的最好的解释是在一本书中，而这本书已经过时，并且没有描述任何当前的C ++实现：

"vertical-align: inherit;"><font style="vertical-align: inherit;">《带注释的C ++参考手册》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

具有关键布局示例图。</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二章有一个非常简短的解释

yle="vertical-align: inherit;">};

"vertical-align: inherit;">};

="vertical-align: inherit;">每个类都有自己的vtbl，由该类的所有对象共享。

的，单独的和未充分使用的工具。

定的代码。</font><font style="vertical-align: inherit;">整数大小和浮点计算的舍入行为属于此类。

font style="vertical-align: inherit;">

tyle="vertical-align: inherit;">

果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
情况下，要捕获单独编译的翻译单元之间的不一致可能非常困难。</font><font style="vertical-align: inherit;">一致使用头文件有助于最大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

l-align: inherit;">例如：

ut &lt;&lt; 1; </font><font style="vertical-align: inherit;">}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

>

herit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

以允许编译器产生最佳代码。</font><font style="vertical-align: inherit;">据称，可以给编译器带来这种自由的结果与要求“从左至右进行常规评估”之间的差异可能很大。</font><font style="vertical-align: inherit;">我不敢相信，但是随着无数的编译器“自由地”利用了自由，并且一些人热情地捍卫了这种自由，改变将是困难的，并且可
需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是，并非所有编译器都针对++ i + i ++之类的代码发出警告。</font><font style="vertical-align: inherit;">同样，参数的求值顺序也未指定。

it;">

it;">

align: inherit;">

东西-不在语言中？

 style="vertical-align: inherit;"><font style="vertical-align: inherit;">D＆E</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

 b）{a == b; </font><font style="vertical-align: inherit;">a！= b; </font><font style="verticaont>

: inherit;">

ical-align: inherit;"><font style="vertical-align: inherit;">

如：

 inherit;">

：

n: inherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误：p1不是int *

inherit;">

nherit;">	int * p，p1; </font><font style="vertical-align: inherit;">//可能的错误？

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

n: inherit;">

这种情况下，“将对象的类型构建为名称”只会使抽象复杂化并使其最小化。</font><font style="vertical-align: inherit;">在每种方案中，将有关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
ple understand 

hat your 

"vertical-align: inherit;"><font style="vertical-align: inherit;">

识符（例如element_count）中的单词分开，而不是使用诸如elementCount和ElementCount之类的替代词。</font><font style="vertical-align: inherit;">切勿使用全大写字母的名称（例如，BEGIN_TRANSACTION），因为按惯例，这是为宏保留的。</font><font style="vertical-align: inherit;">即使您不使用宏，也可能有人乱抛了您的头文件。</font><font style="vertical-al
ign: inherit;">对于类型（例如Square和Graph），请使用首字母大写。</font><font style="vertical-align: inherit;">C ++语言和标准库不使用大写字母，因此它是int而不是Int和string而不是String。</font><font style="vertical-align: inherit;">这样，您可以识别标准类型。

</font><font style="vertical-align: inherit;">例如：

</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int a = 1; </font><font style="vertical-align: inherit;">// 好</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

	int const b = 2; </font><font style="vertical-align: inherit;">//也可以</font></font><font></font>

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

ical-align: inherit;"><font style="vertical-align: inherit;">	int * const p1 = q; </font><font style="vertical-align: inherit;">//指向int变量的常量指针</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ign: inherit;">

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

way const<font></font>

t;">

转换导致错误的可能性要小一些。</font><font style="vertical-align: inherit;">原则上，可以使用static_cast的结果而无需将其强制转换回其原始类型，而为了确保可移植性，应始终始终将reinterpret_cast的结果强制转换回其原始类型。

"vertical-align: inherit;">例如，“ someheader.h”可能包含：

"vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个
主要原因：人类和编译器会看到不同的事物。

;">

e="vertical-align: inherit;">

><font style="erit;">

font>

n: inherit;"><font style="vertical-align: inherit;">

</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;">



inherit;"><font style="vertical-align: inherit;">	/ * C代码：* /</font></font><font></font>

C ++而言，两者都是“正确的”，并且两者的含义完全相同。</font><font style="vertical-align: inherit;">就语言定义和编译器而言，我们也可以说``int * p;''或``int * p;''

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

对于正确使用C ++的更高级部分非常重要。

的可能性要小得多：

-align: inherit;"><font style="vertical-align: inherit;">

rtical-align: inherit;">。

inherit;"><font style="vertical-align: inherit;">

lt;max; ++ i）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

ont></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

关语言技术细节的信息（例如，范围，存储类，句法类别）嵌入名称的每种方案，在不同程度上都存在类似的问题。</font><font style="vertical-align: inherit;">我同意，在某些情况下，将类型提示
建到变量名称中可能会有所帮助，但总的来说，</font><font style="vertical-align: inherit;">尤其是随着软件的发展，这将成为维护的隐患，并严重
</font><font style="vertical-align: inherit;">一些早期用户-特别是我-只是喜欢 

e="vertical-align: inherit;">	const int c = 10;

al-align: inherit;"><font style="vertical-align: inherit;">

t”始终位于“ *”之后。</font><font style="vertical-align: inherit;">例如：

换的作用。</font><font style="vertical-align: inherit;">有时，新手程序员认为这是一个优点，当新手猜错了的时候，这也是一些细微错误的来源。

 p1 = (double*) &amp;a;			// ok (but a is not a double)<font></font>

 p2 = static_cast&lt;double*&gt;(&amp;a);	// error<font></font>

 p2 = reinterpret_cast&lt;double*&gt;(&amp;a);	// ok: I really mean it<font></font>

font>

nt c = 7;<font></font>

 inherit;"><font style="vertical-align: inherit;">

font></a></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

font style="vertical-align: inherit;">这通常是引起细微而不是细微问题的原因。</font><font style="vertical-align: inherit;">因此，C ++提供了更适合其他C ++的替代方法，例如内联函数，模板和名称空间。

herit;"><font style="vertical-align: inherit;">

ader.h”</font></font><font></font>

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

中具有宏（仅宏）之类的约定会有所帮助，但没有针对宏的语言级保护。</font><font style="vertical-align: inherit;">例如，成员名称在struct范围内这一事实无济于事：在编译器正确看到宏之前，宏在程序上作为字符流进行操作。</font><font style="vertical-align: inherit;">顺便说一下，这是为什么C和C ++程序开发环境和工具如此简单的一个主要原因：人类和编译器会看到不同的事物。

><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

不能假设其他程序员始终如一地避免您认为“非常愚蠢”的事情。</font><font style="vertical-align: inherit;">例如，最近有人告诉我，他们遇到了一个包含goto的宏。</font><font style="vertical-align: inherit;">我也看到了这一点，并听到了在微弱的时刻似乎有意义的论点。</font><font style="vertical-align: inherit;">例如：

p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	#define前缀get_ready（）; </font><font style="vertical-align: inherit;">int ret__</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ign: inherit;">

</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

"vertical-align: inherit;"><font style="vertical-align: inherit;">

vertical-align: inherit;"><font style="vertical-align: inherit;">

style="vertical-align: inherit;">

e="vertical-align: inherit;"><font style="vertical-align: inherit;">

re><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	const int S = 10;</font></font><font></font>

nt></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

: inherit;"><font style="vertical-align: inherit;">

的相互作用非常差。</font><font style="vertical-align: inherit;">考虑：

: inherit;">/ * ... * /};</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

t style="vertical-align: inherit;">

作-在大多数情况下都是这种情况。</font><font style="vertical-align: inherit;">如果改用向量，则错误将在编译时捕获：

">

合适的值，因此必须避免。</font><font style="vertical-align: inherit;">这些天来这种情况不太常见。

t style="vertical-align: inherit;"><font style="vertical-align: inherit;">《带注释的C ++参考手册》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 

rit;">它具有关键布局示例图。</font></font><a href="http://www.stroustrup.com/3rd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC ++ PL的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二章有一个非常简短的解释

t style="vertical-align: inherit;">基本上，在C和C ++中，如果在表达式中读取了两次变量（在该变量中也写入了变量），则结果是不确定的。</font><font style="vertical-align: inherit;">不要那样做 </font><font style="vertical-align: inherit;">另一个示例是：

vertical-align: inherit;"><font style="vertical-align: inherit;">	v [i] = i ++;

"vertical-align: inherit;"><font style="vertical-align: inherit;">

可能会警告此类示例，这些示例通常是细微的错误（或潜在的细微错误）。</font><font style="vertical-align: inherit;">令我失望的是，几十年来，大多数编译器仍然没有发出警告，而是将工作交给了专门的，单独的和未充分使用的工具。

: inherit;">

直接表示，没有任何开销。</font><font style="vertical-align: inherit;">指针上的原始操作直接映射到机器指令上。</font><font style="vertical-align: inherit;">特别是，不进行范围检查。</font><font style="vertical-align: inherit;">进行范围检查会增加运行时间和代码大小。</font><font style="vertical-align: inherit;">C的设计要比操作系统任务的汇编代码更
具竞争力，因此这是必要的决定。</font><font style="vertical-align: inherit;">另外，与C ++不同，C如果编译器决定生成代码来检测违规，它就没有合理的方式报告违规情况：C中没有例外。出于兼容性的原因，C ++跟在C之后，并且C ++也直接与汇编程序竞争（在OS，嵌入式系统和某些数字计算区域中）。</font><font style="vertical-align: inherit;">如果要进行范围检查，请使用合适的检查类（向量，智能指针，字符串，<
it;"><font style="vertical-align: inherit;">

大程度地减少此类问题，并且有迹象表明链接程序正在改进。</font><font style="vertical-align: inherit;">请注意，C ++链接程序确实捕获几乎所有与不一致声明的函数有关的错误。

常规评估”之间的差异可能很大。</font><font style="vertical-align: inherit;">我不敢相信，但是随着无数的编译器“自由地”利用了自由，并且一些人热情地捍卫了这种自由，改变将是困难的，并且可能需要数十年才能渗透到C和C ++世界的遥远角落。</font><font style="vertical-align: inherit;">令我失望的是